{"ast":null,"code":"/*!\n* chartjs-plugin-zoom v2.2.0\n* https://www.chartjs.org/chartjs-plugin-zoom/2.2.0/\n * (c) 2016-2024 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, almostEquals, callback, sign, getRelativePosition, _isPointInArea } from 'chart.js/helpers';\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({\n      chart\n    }).indexOf(dir) !== -1;\n  }\n  return false;\n}\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({\n      chart\n    });\n  }\n  if (typeof mode === 'string') {\n    return {\n      x: mode.indexOf('x') !== -1,\n      y: mode.indexOf('y') !== -1\n    };\n  }\n  return {\n    x: false,\n    y: false\n  };\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\nfunction getScaleUnderPoint(_ref, chart) {\n  let {\n    x,\n    y\n  } = _ref;\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {\n    mode = 'xy',\n    scaleMode,\n    overScaleMode\n  } = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n  const enabledScales = [];\n  each(chart.scales, function (scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {},\n      dragging: false,\n      panning: false\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction zoomDelta(val, min, range, newRange) {\n  const minPercent = Math.max(0, Math.min(1, (val - min) / range || 0));\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\nfunction getValueAtPoint(scale, point) {\n  const pixel = scale.isHorizontal() ? point.x : point.y;\n  return scale.getValueForPixel(pixel);\n}\nfunction linearZoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerValue = getValueAtPoint(scale, center);\n  return zoomDelta(centerValue, scale.min, range, newRange);\n}\nfunction logarithmicZoomRange(scale, zoom, center) {\n  const centerValue = getValueAtPoint(scale, center);\n  if (centerValue === undefined) {\n    return {\n      min: scale.min,\n      max: scale.max\n    };\n  }\n  const logMin = Math.log10(scale.min);\n  const logMax = Math.log10(scale.max);\n  const logCenter = Math.log10(centerValue);\n  const logRange = logMax - logMin;\n  const newLogRange = logRange * (zoom - 1);\n  const delta = zoomDelta(logCenter, logMin, logRange, newLogRange);\n  return {\n    min: Math.pow(10, logMin + delta.min),\n    max: Math.pow(10, logMax - delta.max)\n  };\n}\nfunction getScaleLimits(scale, limits) {\n  return limits && (limits[scale.id] || limits[scale.axis]) || {};\n}\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\nfunction linearRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\nfunction fixRange(range, _ref2, originalLimits) {\n  let {\n    min,\n    max,\n    minLimit,\n    maxLimit\n  } = _ref2;\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n  const origMin = originalLimits.min.options ?? originalLimits.min.scale;\n  const origMax = originalLimits.max.options ?? originalLimits.max.scale;\n  const epsilon = range / 1e6;\n  if (almostEquals(min, origMin, epsilon)) {\n    min = origMin;\n  }\n  if (almostEquals(max, origMax, epsilon)) {\n    max = origMax;\n  }\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  return {\n    min,\n    max\n  };\n}\nfunction updateRange(scale, _ref3, limits) {\n  let {\n    min,\n    max\n  } = _ref3;\n  let zoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const state = getState(scale.chart);\n  const {\n    options: scaleOpts\n  } = scale;\n  const scaleLimits = getScaleLimits(scale, limits);\n  const {\n    minRange = 0\n  } = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  if (zoom === 'pan' && (min < minLimit || max > maxLimit)) {\n    return true;\n  }\n  const scaleRange = scale.max - scale.min;\n  const range = zoom ? Math.max(max - min, minRange) : scaleRange;\n  if (zoom && range === minRange && scaleRange <= minRange) {\n    return true;\n  }\n  const newRange = fixRange(range, {\n    min,\n    max,\n    minLimit,\n    maxLimit\n  }, state.originalScaleLimits[scale.id]);\n  scaleOpts.min = newRange.min;\n  scaleOpts.max = newRange.max;\n  state.updatedScaleLimits[scale.id] = newRange;\n  return scale.parse(newRange.min) !== scale.min || scale.parse(newRange.max) !== scale.max;\n}\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  const newRange = {\n    min: scale.min + delta.min,\n    max: scale.max - delta.max\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomLogarithmicScale(scale, zoom, center, limits) {\n  const newRange = logarithmicZoomRange(scale, zoom, center);\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, linearRange(scale, from, to), limits, true);\n}\nconst integerChange = v => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {\n    min: scale.min + integerChange(delta.min),\n    max: scale.max - integerChange(delta.max)\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {\n    min,\n    max\n  } = scale;\n  const range = Math.max(max - min, 1);\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n  return updateRange(scale, {\n    min,\n    max\n  }, limits) || applied;\n}\nconst OFFSETS = {\n  second: 500,\n  minute: 30 * 1000,\n  hour: 30 * 60 * 1000,\n  day: 12 * 60 * 60 * 1000,\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  month: 15 * 24 * 60 * 60 * 1000,\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  year: 182 * 24 * 60 * 60 * 1000\n};\nfunction panNumericalScale(scale, delta, limits) {\n  let pan = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const {\n    min: prevStart,\n    max: prevEnd,\n    options\n  } = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  if (isNaN(newMin) || isNaN(newMax)) {\n    return true;\n  }\n  return updateRange(scale, {\n    min: newMin,\n    max: newMax\n  }, limits, pan ? 'pan' : false);\n}\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n  logarithmic: zoomLogarithmicScale\n};\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale\n};\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {\n    id,\n    options: {\n      min,\n      max\n    }\n  } = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\nfunction storeOriginalScaleLimits(chart, state) {\n  const {\n    scales\n  } = chart;\n  const {\n    originalScaleLimits,\n    updatedScaleLimits\n  } = state;\n  each(scales, function (scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {\n          scale: scale.min,\n          options: scale.options.min\n        },\n        max: {\n          scale: scale.max,\n          options: scale.options.max\n        }\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\nfunction doZoomRect(scale, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, from, to, limits]);\n}\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2\n  };\n}\nfunction zoom(chart, amount) {\n  let transition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';\n  let trigger = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'api';\n  const {\n    x = 1,\n    y = 1,\n    focalPoint = getCenter(chart)\n  } = typeof amount === 'number' ? {\n    x: amount,\n    y: amount\n  } : amount;\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart,\n    trigger\n  }]);\n}\nfunction zoomRect(chart, p0, p1) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  let trigger = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'api';\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  const {\n    mode = 'xy'\n  } = zoomOptions;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart,\n    trigger\n  }]);\n}\nfunction zoomScale(chart, scaleId, range) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  let trigger = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'api';\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n  callback(state.options.zoom?.onZoom, [{\n    chart,\n    trigger\n  }]);\n}\nfunction resetZoom(chart) {\n  let transition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function (scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n    delete state.updatedScaleLimits[scale.id];\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{\n    chart\n  }]);\n}\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {\n    min,\n    max\n  } = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function (scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\nfunction panScale(scale, delta, limits, state) {\n  const {\n    panDelta\n  } = state;\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    panDelta[scale.id] = 0;\n  } else {\n    panDelta[scale.id] = delta;\n  }\n}\nfunction pan(chart, delta, enabledScales) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  const {\n    x = 0,\n    y = 0\n  } = typeof delta === 'number' ? {\n    x: delta,\n    y: delta\n  } : delta;\n  const state = getState(chart);\n  const {\n    options: {\n      pan: panOptions,\n      limits\n    }\n  } = state;\n  const {\n    onPan\n  } = panOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{\n    chart\n  }]);\n}\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min,\n      max\n    } = state.originalScaleLimits[scaleId] || {\n      min: {},\n      max: {}\n    };\n    scaleBounds[scaleId] = {\n      min: min.scale,\n      max: max.scale\n    };\n  }\n  return scaleBounds;\n}\nfunction getZoomedScaleBounds(chart) {\n  const state = getState(chart);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    scaleBounds[scaleId] = state.updatedScaleLimits[scaleId];\n  }\n  return scaleBounds;\n}\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min: originalMin,\n      max: originalMax\n    } = scaleBounds[scaleId];\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isZoomingOrPanning(chart) {\n  const state = getState(chart);\n  return state.panning || state.dragging;\n}\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\nfunction removeHandler(chart, type) {\n  const {\n    handlers\n  } = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\nfunction addHandler(chart, target, type, handler) {\n  const {\n    handlers,\n    options\n  } = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = event => handler(chart, event, options);\n  handlers[type].target = target;\n  const passive = type === 'wheel' ? false : undefined;\n  target.addEventListener(type, handlers[type], {\n    passive\n  });\n}\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\nfunction getPointPosition(event, chart) {\n  if (event.target !== chart.canvas) {\n    const canvasArea = chart.canvas.getBoundingClientRect();\n    return {\n      x: event.clientX - canvasArea.left,\n      y: event.clientY - canvasArea.top\n    };\n  }\n  return getRelativePosition(event, chart);\n}\nfunction zoomStart(chart, event, zoomOptions) {\n  const {\n    onZoomStart,\n    onZoomRejected\n  } = zoomOptions;\n  if (onZoomStart) {\n    const point = getPointPosition(event, chart);\n    if (callback(onZoomStart, [{\n      chart,\n      event,\n      point\n    }]) === false) {\n      callback(onZoomRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n  }\n}\nfunction mouseDown(chart, event) {\n  if (chart.legend) {\n    const point = getRelativePosition(event, chart);\n    if (_isPointInArea(point, chart.legend)) {\n      return;\n    }\n  }\n  const state = getState(chart);\n  const {\n    pan: panOptions,\n    zoom: zoomOptions = {}\n  } = state.options;\n  if (event.button !== 0 || keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n  addHandler(chart, chart.canvas.ownerDocument, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\nfunction applyAspectRatio(_ref4, aspectRatio) {\n  let {\n    begin,\n    end\n  } = _ref4;\n  let width = end.x - begin.x;\n  let height = end.y - begin.y;\n  const ratio = Math.abs(width / height);\n  if (ratio > aspectRatio) {\n    width = Math.sign(width) * Math.abs(height * aspectRatio);\n  } else if (ratio < aspectRatio) {\n    height = Math.sign(height) * Math.abs(width / aspectRatio);\n  }\n  end.x = begin.x + width;\n  end.y = begin.y + height;\n}\nfunction applyMinMaxProps(rect, chartArea, points, _ref5) {\n  let {\n    min,\n    max,\n    prop\n  } = _ref5;\n  rect[min] = clamp(Math.min(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n  rect[max] = clamp(Math.max(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n}\nfunction getRelativePoints(chart, pointEvents, maintainAspectRatio) {\n  const points = {\n    begin: getPointPosition(pointEvents.dragStart, chart),\n    end: getPointPosition(pointEvents.dragEnd, chart)\n  };\n  if (maintainAspectRatio) {\n    const aspectRatio = chart.chartArea.width / chart.chartArea.height;\n    applyAspectRatio(points, aspectRatio);\n  }\n  return points;\n}\nfunction computeDragRect(chart, mode, pointEvents, maintainAspectRatio) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  const {\n    top,\n    left,\n    right,\n    bottom,\n    width: chartWidth,\n    height: chartHeight\n  } = chart.chartArea;\n  const rect = {\n    top,\n    left,\n    right,\n    bottom\n  };\n  const points = getRelativePoints(chart, pointEvents, maintainAspectRatio && xEnabled && yEnabled);\n  if (xEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {\n      min: 'left',\n      max: 'right',\n      prop: 'x'\n    });\n  }\n  if (yEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {\n      min: 'top',\n      max: 'bottom',\n      prop: 'y'\n    });\n  }\n  const width = rect.right - rect.left;\n  const height = rect.bottom - rect.top;\n  return {\n    ...rect,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1\n  };\n}\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n  removeHandler(chart, 'mousemove');\n  const {\n    mode,\n    onZoomComplete,\n    drag: {\n      threshold = 0,\n      maintainAspectRatio\n    }\n  } = state.options.zoom;\n  const rect = computeDragRect(chart, mode, {\n    dragStart: state.dragStart,\n    dragEnd: event\n  }, maintainAspectRatio);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n  state.dragStart = state.dragEnd = null;\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n  zoomRect(chart, {\n    x: rect.left,\n    y: rect.top\n  }, {\n    x: rect.right,\n    y: rect.bottom\n  }, 'zoom', 'drag');\n  state.dragging = false;\n  state.filterNextClick = true;\n  callback(onZoomComplete, [{\n    chart\n  }]);\n}\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n    return;\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\nfunction wheel(chart, event) {\n  const {\n    handlers: {\n      onZoomComplete\n    },\n    options: {\n      zoom: zoomOptions\n    }\n  } = getState(chart);\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const speed = zoomOptions.wheel.speed;\n  const percentage = event.deltaY >= 0 ? 2 - 1 / (1 - speed) : 1 + speed;\n  const amount = {\n    x: percentage,\n    y: percentage,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount, 'zoom', 'wheel');\n  callback(onZoomComplete, [{\n    chart\n  }]);\n}\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{\n      chart\n    }]), delay);\n  }\n}\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {\n    wheel: wheelOptions,\n    drag: dragOptions,\n    onZoomComplete\n  } = options.zoom;\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\nfunction createEnabler(chart, state) {\n  return function (recognizer, event) {\n    const {\n      pan: panOptions,\n      zoom: zoomOptions = {}\n    } = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) {\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {\n      callback(panOptions.onPanRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n    return true;\n  };\n}\nfunction pinchAxes(p0, p1) {\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {\n      center,\n      pointers\n    } = e;\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount, 'zoom', 'pinch');\n    state.scale = e.scale;\n  }\n}\nfunction startPinch(chart, state, event) {\n  if (state.options.zoom.pinch.enabled) {\n    const point = getRelativePosition(event, chart);\n    if (callback(state.options.zoom.onZoomStart, [{\n      chart,\n      event,\n      point\n    }]) === false) {\n      state.scale = null;\n      callback(state.options.zoom.onZoomRejected, [{\n        chart,\n        event\n      }]);\n    } else {\n      state.scale = 1;\n    }\n  }\n}\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null;\n    callback(state.options.zoom.onZoomComplete, [{\n      chart\n    }]);\n  }\n}\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {\n      x: e.deltaX - delta.x,\n      y: e.deltaY - delta.y\n    }, state.panScales);\n    state.delta = {\n      x: e.deltaX,\n      y: e.deltaY\n    };\n  }\n}\nfunction startPan(chart, state, event) {\n  const {\n    enabled,\n    onPanStart,\n    onPanRejected\n  } = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n  if (callback(onPanStart, [{\n    chart,\n    event,\n    point\n  }]) === false) {\n    return callback(onPanRejected, [{\n      chart,\n      event\n    }]);\n  }\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {\n    x: 0,\n    y: 0\n  };\n  handlePan(chart, state, event);\n}\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panning = false;\n    state.filterNextClick = true;\n    callback(state.options.pan.onPanComplete, [{\n      chart\n    }]);\n  }\n}\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {\n    pan: panOptions,\n    zoom: zoomOptions\n  } = options;\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', e => startPinch(chart, state, e));\n    mc.on('pinch', e => handlePinch(chart, state, e));\n    mc.on('pinchend', e => endPinch(chart, state, e));\n  }\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', e => startPan(chart, state, e));\n    mc.on('panmove', e => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n  hammers.set(chart, mc);\n}\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\nfunction hammerOptionsChanged(oldOptions, newOptions) {\n  const {\n    pan: oldPan,\n    zoom: oldZoom\n  } = oldOptions;\n  const {\n    pan: newPan,\n    zoom: newZoom\n  } = newOptions;\n  if (oldZoom?.zoom?.pinch?.enabled !== newZoom?.zoom?.pinch?.enabled) {\n    return true;\n  }\n  if (oldPan?.enabled !== newPan?.enabled) {\n    return true;\n  }\n  if (oldPan?.threshold !== newPan?.threshold) {\n    return true;\n  }\n  return false;\n}\nvar version = \"2.2.0\";\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {\n    dragStart,\n    dragEnd\n  } = getState(chart);\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {\n    left,\n    top,\n    width,\n    height\n  } = computeDragRect(chart, options.zoom.mode, {\n    dragStart,\n    dragEnd\n  }, dragOptions.maintainAspectRatio);\n  const ctx = chart.ctx;\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy'\n    }\n  },\n  start: function (chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode') || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = transition => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.getZoomedScaleBounds = () => getZoomedScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n    chart.isZoomingOrPanning = () => isZoomingOrPanning(chart);\n  },\n  beforeEvent(chart, _ref6) {\n    let {\n      event\n    } = _ref6;\n    if (isZoomingOrPanning(chart)) {\n      return false;\n    }\n    if (event.type === 'click' || event.type === 'mouseup') {\n      const state = getState(chart);\n      if (state.filterNextClick) {\n        state.filterNextClick = false;\n        return false;\n      }\n    }\n  },\n  beforeUpdate: function (chart, args, options) {\n    const state = getState(chart);\n    const previousOptions = state.options;\n    state.options = options;\n    if (hammerOptionsChanged(previousOptions, options)) {\n      stopHammer(chart);\n      startHammer(chart, options);\n    }\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n  stop: function (chart) {\n    removeListeners(chart);\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions\n};\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };","map":{"version":3,"names":["Hammer","each","valueOrDefault","almostEquals","callback","sign","getRelativePosition","_isPointInArea","getModifierKey","opts","enabled","modifierKey","keyPressed","key","event","keyNotPressed","directionEnabled","mode","dir","chart","undefined","indexOf","directionsEnabled","x","y","debounce","fn","delay","timeout","clearTimeout","setTimeout","getScaleUnderPoint","_ref","scales","scaleIds","Object","keys","i","length","scale","top","bottom","left","right","getEnabledScalesByPoint","options","point","scaleMode","overScaleMode","scaleEnabled","overScaleEnabled","axis","enabledScales","scaleItem","push","chartStates","WeakMap","getState","state","get","originalScaleLimits","updatedScaleLimits","handlers","panDelta","dragging","panning","set","removeState","delete","zoomDelta","val","min","range","newRange","minPercent","Math","max","maxPercent","getValueAtPoint","pixel","isHorizontal","getValueForPixel","linearZoomDelta","zoom","center","centerValue","logarithmicZoomRange","logMin","log10","logMax","logCenter","logRange","newLogRange","delta","pow","getScaleLimits","limits","id","getLimit","scaleLimits","prop","fallback","limit","original","linearRange","pixel0","pixel1","v0","v1","fixRange","_ref2","originalLimits","minLimit","maxLimit","offset","origMin","origMax","epsilon","updateRange","_ref3","arguments","scaleOpts","minRange","Infinity","scaleRange","parse","zoomNumericalScale","zoomLogarithmicScale","zoomRectNumericalScale","from","to","integerChange","v","isNaN","round","existCategoryFromMaxZoom","labels","getLabels","maxIndex","zoomCategoryScale","scaleLength","width","height","panCategoryScale","lastLabelIndex","stepDelta","stepSize","abs","applied","OFFSETS","second","minute","hour","day","week","month","quarter","year","panNumericalScale","pan","prevStart","prevEnd","time","newMin","getPixelForValue","newMax","panNonLinearScale","zoomFunctions","category","default","logarithmic","zoomRectFunctions","panFunctions","timeseries","shouldUpdateScaleLimits","previous","removeMissingScales","opt","storeOriginalScaleLimits","doZoom","amount","type","doZoomRect","getCenter","ca","chartArea","transition","trigger","focalPoint","zoomOptions","xEnabled","yEnabled","update","onZoom","zoomRect","p0","p1","zoomScale","scaleId","resetZoom","scaleOptions","onZoomComplete","getOriginalRange","getZoomLevel","origRange","level","panScale","storedDelta","panOptions","onPan","getInitialScaleBounds","scaleBounds","getZoomedScaleBounds","isZoomedOrPanned","originalMin","originalMax","isZoomingOrPanning","clamp","removeHandler","handler","target","removeEventListener","addHandler","oldHandler","passive","addEventListener","mouseMove","dragStart","dragEnd","keyDown","getPointPosition","canvas","canvasArea","getBoundingClientRect","clientX","clientY","zoomStart","onZoomStart","onZoomRejected","mouseDown","legend","button","drag","ownerDocument","window","document","applyAspectRatio","_ref4","aspectRatio","begin","end","ratio","applyMinMaxProps","rect","points","_ref5","getRelativePoints","pointEvents","maintainAspectRatio","computeDragRect","chartWidth","chartHeight","zoomX","zoomY","mouseUp","threshold","distanceX","distanceY","distance","sqrt","filterNextClick","wheelPreconditions","wheel","cancelable","preventDefault","deltaY","speed","percentage","addDebouncedHandler","name","addListeners","wheelOptions","dragOptions","removeListeners","createEnabler","recognizer","srcEvent","pointerType","onPanRejected","pinchAxes","pinchX","pinchY","p","handlePinch","e","pointers","zoomPercent","pinch","startPinch","endPinch","handlePan","deltaX","panScales","startPan","onPanStart","endPan","onPanComplete","hammers","startHammer","mc","Manager","add","Pinch","on","Pan","enable","stopHammer","remove","destroy","hammerOptionsChanged","oldOptions","newOptions","oldPan","oldZoom","newPan","newZoom","version","draw","caller","drawTime","ctx","save","beginPath","fillStyle","backgroundColor","fillRect","borderWidth","lineWidth","strokeStyle","borderColor","strokeRect","restore","plugin","defaults","start","_args","prototype","hasOwnProperty","call","console","warn","args","beforeEvent","_ref6","beforeUpdate","previousOptions","beforeDatasetsDraw","afterDatasetsDraw","beforeDraw","afterDraw","stop"],"sources":["C:/Users/850_G5/Documents/Formation_Dot_Net/myday/front-end/node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js"],"sourcesContent":["/*!\n* chartjs-plugin-zoom v2.2.0\n* https://www.chartjs.org/chartjs-plugin-zoom/2.2.0/\n * (c) 2016-2024 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, almostEquals, callback, sign, getRelativePosition, _isPointInArea } from 'chart.js/helpers';\n\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({chart}).indexOf(dir) !== -1;\n  }\n  return false;\n}\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({chart});\n  }\n  if (typeof mode === 'string') {\n    return {x: mode.indexOf('x') !== -1, y: mode.indexOf('y') !== -1};\n  }\n  return {x: false, y: false};\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\nfunction getScaleUnderPoint({x, y}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {mode = 'xy', scaleMode, overScaleMode} = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n  const enabledScales = [];\n  each(chart.scales, function(scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {},\n      dragging: false,\n      panning: false\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(val, min, range, newRange) {\n  const minPercent = Math.max(0, Math.min(1, (val - min) / range || 0));\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\nfunction getValueAtPoint(scale, point) {\n  const pixel = scale.isHorizontal() ? point.x : point.y;\n  return scale.getValueForPixel(pixel);\n}\nfunction linearZoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerValue = getValueAtPoint(scale, center);\n  return zoomDelta(centerValue, scale.min, range, newRange);\n}\nfunction logarithmicZoomRange(scale, zoom, center) {\n  const centerValue = getValueAtPoint(scale, center);\n  if (centerValue === undefined) {\n    return {min: scale.min, max: scale.max};\n  }\n  const logMin = Math.log10(scale.min);\n  const logMax = Math.log10(scale.max);\n  const logCenter = Math.log10(centerValue);\n  const logRange = logMax - logMin;\n  const newLogRange = logRange * (zoom - 1);\n  const delta = zoomDelta(logCenter, logMin, logRange, newLogRange);\n  return {\n    min: Math.pow(10, logMin + delta.min),\n    max: Math.pow(10, logMax - delta.max),\n  };\n}\nfunction getScaleLimits(scale, limits) {\n  return limits && (limits[scale.id] || limits[scale.axis]) || {};\n}\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\nfunction linearRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\nfunction fixRange(range, {min, max, minLimit, maxLimit}, originalLimits) {\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n  const origMin = originalLimits.min.options ?? originalLimits.min.scale;\n  const origMax = originalLimits.max.options ?? originalLimits.max.scale;\n  const epsilon = range / 1e6;\n  if (almostEquals(min, origMin, epsilon)) {\n    min = origMin;\n  }\n  if (almostEquals(max, origMax, epsilon)) {\n    max = origMax;\n  }\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  return {min, max};\n}\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {options: scaleOpts} = scale;\n  const scaleLimits = getScaleLimits(scale, limits);\n  const {minRange = 0} = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  if (zoom === 'pan' && (min < minLimit || max > maxLimit)) {\n    return true;\n  }\n  const scaleRange = scale.max - scale.min;\n  const range = zoom ? Math.max(max - min, minRange) : scaleRange;\n  if (zoom && range === minRange && scaleRange <= minRange) {\n    return true;\n  }\n  const newRange = fixRange(range, {min, max, minLimit, maxLimit}, state.originalScaleLimits[scale.id]);\n  scaleOpts.min = newRange.min;\n  scaleOpts.max = newRange.max;\n  state.updatedScaleLimits[scale.id] = newRange;\n  return scale.parse(newRange.min) !== scale.min || scale.parse(newRange.max) !== scale.max;\n}\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomLogarithmicScale(scale, zoom, center, limits) {\n  const newRange = logarithmicZoomRange(scale, zoom, center);\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, linearRange(scale, from, to), limits, true);\n}\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\n  return updateRange(scale, newRange, limits, true);\n}\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {min, max} = scale;\n  const range = Math.max(max - min, 1);\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n  return updateRange(scale, {min, max}, limits) || applied;\n}\nconst OFFSETS = {\n  second: 500,\n  minute: 30 * 1000,\n  hour: 30 * 60 * 1000,\n  day: 12 * 60 * 60 * 1000,\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  month: 15 * 24 * 60 * 60 * 1000,\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  year: 182 * 24 * 60 * 60 * 1000\n};\nfunction panNumericalScale(scale, delta, limits, pan = false) {\n  const {min: prevStart, max: prevEnd, options} = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  if (isNaN(newMin) || isNaN(newMax)) {\n    return true;\n  }\n  return updateRange(scale, {min: newMin, max: newMax}, limits, pan ? 'pan' : false);\n}\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n  logarithmic: zoomLogarithmicScale,\n};\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale,\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {id, options: {min, max}} = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\nfunction storeOriginalScaleLimits(chart, state) {\n  const {scales} = chart;\n  const {originalScaleLimits, updatedScaleLimits} = state;\n  each(scales, function(scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {scale: scale.min, options: scale.options.min},\n        max: {scale: scale.max, options: scale.options.max},\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\nfunction doZoomRect(scale, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, from, to, limits]);\n}\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  };\n}\nfunction zoom(chart, amount, transition = 'none', trigger = 'api') {\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{chart, trigger}]);\n}\nfunction zoomRect(chart, p0, p1, transition = 'none', trigger = 'api') {\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy'} = zoomOptions;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{chart, trigger}]);\n}\nfunction zoomScale(chart, scaleId, range, transition = 'none', trigger = 'api') {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n  callback(state.options.zoom?.onZoom, [{chart, trigger}]);\n}\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function(scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n    delete state.updatedScaleLimits[scale.id];\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{chart}]);\n}\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {min, max} = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function(scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\nfunction panScale(scale, delta, limits, state) {\n  const {panDelta} = state;\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    panDelta[scale.id] = 0;\n  } else {\n    panDelta[scale.id] = delta;\n  }\n}\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\n  const state = getState(chart);\n  const {options: {pan: panOptions, limits}} = state;\n  const {onPan} = panOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{chart}]);\n}\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};\n    scaleBounds[scaleId] = {min: min.scale, max: max.scale};\n  }\n  return scaleBounds;\n}\nfunction getZoomedScaleBounds(chart) {\n  const state = getState(chart);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    scaleBounds[scaleId] = state.updatedScaleLimits[scaleId];\n  }\n  return scaleBounds;\n}\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isZoomingOrPanning(chart) {\n  const state = getState(chart);\n  return state.panning || state.dragging;\n}\n\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\nfunction removeHandler(chart, type) {\n  const {handlers} = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\nfunction addHandler(chart, target, type, handler) {\n  const {handlers, options} = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = (event) => handler(chart, event, options);\n  handlers[type].target = target;\n  const passive = type === 'wheel' ? false : undefined;\n  target.addEventListener(type, handlers[type], {passive});\n}\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\nfunction getPointPosition(event, chart) {\n  if (event.target !== chart.canvas) {\n    const canvasArea = chart.canvas.getBoundingClientRect();\n    return {\n      x: event.clientX - canvasArea.left,\n      y: event.clientY - canvasArea.top,\n    };\n  }\n  return getRelativePosition(event, chart);\n}\nfunction zoomStart(chart, event, zoomOptions) {\n  const {onZoomStart, onZoomRejected} = zoomOptions;\n  if (onZoomStart) {\n    const point = getPointPosition(event, chart);\n    if (callback(onZoomStart, [{chart, event, point}]) === false) {\n      callback(onZoomRejected, [{chart, event}]);\n      return false;\n    }\n  }\n}\nfunction mouseDown(chart, event) {\n  if (chart.legend) {\n    const point = getRelativePosition(event, chart);\n    if (_isPointInArea(point, chart.legend)) {\n      return;\n    }\n  }\n  const state = getState(chart);\n  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n  if (\n    event.button !== 0 ||\n    keyPressed(getModifierKey(panOptions), event) ||\n    keyNotPressed(getModifierKey(zoomOptions.drag), event)\n  ) {\n    return callback(zoomOptions.onZoomRejected, [{chart, event}]);\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n  addHandler(chart, chart.canvas.ownerDocument, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\nfunction applyAspectRatio({begin, end}, aspectRatio) {\n  let width = end.x - begin.x;\n  let height = end.y - begin.y;\n  const ratio = Math.abs(width / height);\n  if (ratio > aspectRatio) {\n    width = Math.sign(width) * Math.abs(height * aspectRatio);\n  } else if (ratio < aspectRatio) {\n    height = Math.sign(height) * Math.abs(width / aspectRatio);\n  }\n  end.x = begin.x + width;\n  end.y = begin.y + height;\n}\nfunction applyMinMaxProps(rect, chartArea, points, {min, max, prop}) {\n  rect[min] = clamp(Math.min(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n  rect[max] = clamp(Math.max(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n}\nfunction getRelativePoints(chart, pointEvents, maintainAspectRatio) {\n  const points = {\n    begin: getPointPosition(pointEvents.dragStart, chart),\n    end: getPointPosition(pointEvents.dragEnd, chart),\n  };\n  if (maintainAspectRatio) {\n    const aspectRatio = chart.chartArea.width / chart.chartArea.height;\n    applyAspectRatio(points, aspectRatio);\n  }\n  return points;\n}\nfunction computeDragRect(chart, mode, pointEvents, maintainAspectRatio) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  const {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\n  const rect = {top, left, right, bottom};\n  const points = getRelativePoints(chart, pointEvents, maintainAspectRatio && xEnabled && yEnabled);\n  if (xEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {min: 'left', max: 'right', prop: 'x'});\n  }\n  if (yEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {min: 'top', max: 'bottom', prop: 'y'});\n  }\n  const width = rect.right - rect.left;\n  const height = rect.bottom - rect.top;\n  return {\n    ...rect,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\n  };\n}\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n  removeHandler(chart, 'mousemove');\n  const {mode, onZoomComplete, drag: {threshold = 0, maintainAspectRatio}} = state.options.zoom;\n  const rect = computeDragRect(chart, mode, {dragStart: state.dragStart, dragEnd: event}, maintainAspectRatio);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n  state.dragStart = state.dragEnd = null;\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom', 'drag');\n  state.dragging = false;\n  state.filterNextClick = true;\n  callback(onZoomComplete, [{chart}]);\n}\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{chart, event}]);\n    return;\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\nfunction wheel(chart, event) {\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const speed = zoomOptions.wheel.speed;\n  const percentage = event.deltaY >= 0 ? 2 - 1 / (1 - speed) : 1 + speed;\n  const amount = {\n    x: percentage,\n    y: percentage,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount, 'zoom', 'wheel');\n  callback(onZoomComplete, [{chart}]);\n}\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{chart}]), delay);\n  }\n}\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\n\nfunction createEnabler(chart, state) {\n  return function(recognizer, event) {\n    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) {\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (\n      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\n    ) {\n      callback(panOptions.onPanRejected, [{chart, event}]);\n      return false;\n    }\n    return true;\n  };\n}\nfunction pinchAxes(p0, p1) {\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {x, y};\n}\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {center, pointers} = e;\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount, 'zoom', 'pinch');\n    state.scale = e.scale;\n  }\n}\nfunction startPinch(chart, state, event) {\n  if (state.options.zoom.pinch.enabled) {\n    const point = getRelativePosition(event, chart);\n    if (callback(state.options.zoom.onZoomStart, [{chart, event, point}]) === false) {\n      state.scale = null;\n      callback(state.options.zoom.onZoomRejected, [{chart, event}]);\n    } else {\n      state.scale = 1;\n    }\n  }\n}\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null;\n    callback(state.options.zoom.onZoomComplete, [{chart}]);\n  }\n}\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\n    state.delta = {x: e.deltaX, y: e.deltaY};\n  }\n}\nfunction startPan(chart, state, event) {\n  const {enabled, onPanStart, onPanRejected} = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n  if (callback(onPanStart, [{chart, event, point}]) === false) {\n    return callback(onPanRejected, [{chart, event}]);\n  }\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {x: 0, y: 0};\n  handlePan(chart, state, event);\n}\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panning = false;\n    state.filterNextClick = true;\n    callback(state.options.pan.onPanComplete, [{chart}]);\n  }\n}\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {pan: panOptions, zoom: zoomOptions} = options;\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', (e) => startPinch(chart, state, e));\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\n  }\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', (e) => startPan(chart, state, e));\n    mc.on('panmove', (e) => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n  hammers.set(chart, mc);\n}\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\nfunction hammerOptionsChanged(oldOptions, newOptions) {\n  const {pan: oldPan, zoom: oldZoom} = oldOptions;\n  const {pan: newPan, zoom: newZoom} = newOptions;\n  if (oldZoom?.zoom?.pinch?.enabled !== newZoom?.zoom?.pinch?.enabled) {\n    return true;\n  }\n  if (oldPan?.enabled !== newPan?.enabled) {\n    return true;\n  }\n  if (oldPan?.threshold !== newPan?.threshold) {\n    return true;\n  }\n  return false;\n}\n\nvar version = \"2.2.0\";\n\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {dragStart, dragEnd} = getState(chart);\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, {dragStart, dragEnd}, dragOptions.maintainAspectRatio);\n  const ctx = chart.ctx;\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null,\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy',\n    }\n  },\n  start: function(chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode')\n      || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.getZoomedScaleBounds = () => getZoomedScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n    chart.isZoomingOrPanning = () => isZoomingOrPanning(chart);\n  },\n  beforeEvent(chart, {event}) {\n    if (isZoomingOrPanning(chart)) {\n      return false;\n    }\n    if (event.type === 'click' || event.type === 'mouseup') {\n      const state = getState(chart);\n      if (state.filterNextClick) {\n        state.filterNextClick = false;\n        return false;\n      }\n    }\n  },\n  beforeUpdate: function(chart, args, options) {\n    const state = getState(chart);\n    const previousOptions = state.options;\n    state.options = options;\n    if (hammerOptionsChanged(previousOptions, options)) {\n      stopHammer(chart);\n      startHammer(chart, options);\n    }\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n  stop: function(chart) {\n    removeListeners(chart);\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions,\n};\n\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,MAAM,MAAM,UAAU;AAC7B,SAASC,IAAI,EAAEC,cAAc,EAAEC,YAAY,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,mBAAmB,EAAEC,cAAc,QAAQ,kBAAkB;AAE1H,MAAMC,cAAc,GAAGC,IAAI,IAAIA,IAAI,IAAIA,IAAI,CAACC,OAAO,IAAID,IAAI,CAACE,WAAW;AACvE,MAAMC,UAAU,GAAGA,CAACC,GAAG,EAAEC,KAAK,KAAKD,GAAG,IAAIC,KAAK,CAACD,GAAG,GAAG,KAAK,CAAC;AAC5D,MAAME,aAAa,GAAGA,CAACF,GAAG,EAAEC,KAAK,KAAKD,GAAG,IAAI,CAACC,KAAK,CAACD,GAAG,GAAG,KAAK,CAAC;AAChE,SAASG,gBAAgBA,CAACC,IAAI,EAAEC,GAAG,EAAEC,KAAK,EAAE;EAC1C,IAAIF,IAAI,KAAKG,SAAS,EAAE;IACtB,OAAO,IAAI;EACb,CAAC,MAAM,IAAI,OAAOH,IAAI,KAAK,QAAQ,EAAE;IACnC,OAAOA,IAAI,CAACI,OAAO,CAACH,GAAG,CAAC,KAAK,CAAC,CAAC;EACjC,CAAC,MAAM,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;IACrC,OAAOA,IAAI,CAAC;MAACE;IAAK,CAAC,CAAC,CAACE,OAAO,CAACH,GAAG,CAAC,KAAK,CAAC,CAAC;EAC1C;EACA,OAAO,KAAK;AACd;AACA,SAASI,iBAAiBA,CAACL,IAAI,EAAEE,KAAK,EAAE;EACtC,IAAI,OAAOF,IAAI,KAAK,UAAU,EAAE;IAC9BA,IAAI,GAAGA,IAAI,CAAC;MAACE;IAAK,CAAC,CAAC;EACtB;EACA,IAAI,OAAOF,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAO;MAACM,CAAC,EAAEN,IAAI,CAACI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;MAAEG,CAAC,EAAEP,IAAI,CAACI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC;IAAC,CAAC;EACnE;EACA,OAAO;IAACE,CAAC,EAAE,KAAK;IAAEC,CAAC,EAAE;EAAK,CAAC;AAC7B;AACA,SAASC,QAAQA,CAACC,EAAE,EAAEC,KAAK,EAAE;EAC3B,IAAIC,OAAO;EACX,OAAO,YAAW;IAChBC,YAAY,CAACD,OAAO,CAAC;IACrBA,OAAO,GAAGE,UAAU,CAACJ,EAAE,EAAEC,KAAK,CAAC;IAC/B,OAAOA,KAAK;EACd,CAAC;AACH;AACA,SAASI,kBAAkBA,CAAAC,IAAA,EAASb,KAAK,EAAE;EAAA,IAAf;IAACI,CAAC;IAAEC;EAAC,CAAC,GAAAQ,IAAA;EAChC,MAAMC,MAAM,GAAGd,KAAK,CAACc,MAAM;EAC3B,MAAMC,QAAQ,GAAGC,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC;EACpC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACxC,MAAME,KAAK,GAAGN,MAAM,CAACC,QAAQ,CAACG,CAAC,CAAC,CAAC;IACjC,IAAIb,CAAC,IAAIe,KAAK,CAACC,GAAG,IAAIhB,CAAC,IAAIe,KAAK,CAACE,MAAM,IAAIlB,CAAC,IAAIgB,KAAK,CAACG,IAAI,IAAInB,CAAC,IAAIgB,KAAK,CAACI,KAAK,EAAE;MAC9E,OAAOJ,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AACA,SAASK,uBAAuBA,CAACC,OAAO,EAAEC,KAAK,EAAE3B,KAAK,EAAE;EACtD,MAAM;IAACF,IAAI,GAAG,IAAI;IAAE8B,SAAS;IAAEC;EAAa,CAAC,GAAGH,OAAO,IAAI,CAAC,CAAC;EAC7D,MAAMN,KAAK,GAAGR,kBAAkB,CAACe,KAAK,EAAE3B,KAAK,CAAC;EAC9C,MAAMT,OAAO,GAAGY,iBAAiB,CAACL,IAAI,EAAEE,KAAK,CAAC;EAC9C,MAAM8B,YAAY,GAAG3B,iBAAiB,CAACyB,SAAS,EAAE5B,KAAK,CAAC;EACxD,IAAI6B,aAAa,EAAE;IACjB,MAAME,gBAAgB,GAAG5B,iBAAiB,CAAC0B,aAAa,EAAE7B,KAAK,CAAC;IAChE,KAAK,MAAMgC,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE;MAC7B,IAAID,gBAAgB,CAACC,IAAI,CAAC,EAAE;QAC1BF,YAAY,CAACE,IAAI,CAAC,GAAGzC,OAAO,CAACyC,IAAI,CAAC;QAClCzC,OAAO,CAACyC,IAAI,CAAC,GAAG,KAAK;MACvB;IACF;EACF;EACA,IAAIZ,KAAK,IAAIU,YAAY,CAACV,KAAK,CAACY,IAAI,CAAC,EAAE;IACrC,OAAO,CAACZ,KAAK,CAAC;EAChB;EACA,MAAMa,aAAa,GAAG,EAAE;EACxBnD,IAAI,CAACkB,KAAK,CAACc,MAAM,EAAE,UAASoB,SAAS,EAAE;IACrC,IAAI3C,OAAO,CAAC2C,SAAS,CAACF,IAAI,CAAC,EAAE;MAC3BC,aAAa,CAACE,IAAI,CAACD,SAAS,CAAC;IAC/B;EACF,CAAC,CAAC;EACF,OAAOD,aAAa;AACtB;AAEA,MAAMG,WAAW,GAAG,IAAIC,OAAO,CAAC,CAAC;AACjC,SAASC,QAAQA,CAACtC,KAAK,EAAE;EACvB,IAAIuC,KAAK,GAAGH,WAAW,CAACI,GAAG,CAACxC,KAAK,CAAC;EAClC,IAAI,CAACuC,KAAK,EAAE;IACVA,KAAK,GAAG;MACNE,mBAAmB,EAAE,CAAC,CAAC;MACvBC,kBAAkB,EAAE,CAAC,CAAC;MACtBC,QAAQ,EAAE,CAAC,CAAC;MACZC,QAAQ,EAAE,CAAC,CAAC;MACZC,QAAQ,EAAE,KAAK;MACfC,OAAO,EAAE;IACX,CAAC;IACDV,WAAW,CAACW,GAAG,CAAC/C,KAAK,EAAEuC,KAAK,CAAC;EAC/B;EACA,OAAOA,KAAK;AACd;AACA,SAASS,WAAWA,CAAChD,KAAK,EAAE;EAC1BoC,WAAW,CAACa,MAAM,CAACjD,KAAK,CAAC;AAC3B;AAEA,SAASkD,SAASA,CAACC,GAAG,EAAEC,GAAG,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EAC5C,MAAMC,UAAU,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACJ,GAAG,CAAC,CAAC,EAAE,CAACD,GAAG,GAAGC,GAAG,IAAIC,KAAK,IAAI,CAAC,CAAC,CAAC;EACrE,MAAMK,UAAU,GAAG,CAAC,GAAGH,UAAU;EACjC,OAAO;IACLH,GAAG,EAAEE,QAAQ,GAAGC,UAAU;IAC1BE,GAAG,EAAEH,QAAQ,GAAGI;EAClB,CAAC;AACH;AACA,SAASC,eAAeA,CAACvC,KAAK,EAAEO,KAAK,EAAE;EACrC,MAAMiC,KAAK,GAAGxC,KAAK,CAACyC,YAAY,CAAC,CAAC,GAAGlC,KAAK,CAACvB,CAAC,GAAGuB,KAAK,CAACtB,CAAC;EACtD,OAAOe,KAAK,CAAC0C,gBAAgB,CAACF,KAAK,CAAC;AACtC;AACA,SAASG,eAAeA,CAAC3C,KAAK,EAAE4C,IAAI,EAAEC,MAAM,EAAE;EAC5C,MAAMZ,KAAK,GAAGjC,KAAK,CAACqC,GAAG,GAAGrC,KAAK,CAACgC,GAAG;EACnC,MAAME,QAAQ,GAAGD,KAAK,IAAIW,IAAI,GAAG,CAAC,CAAC;EACnC,MAAME,WAAW,GAAGP,eAAe,CAACvC,KAAK,EAAE6C,MAAM,CAAC;EAClD,OAAOf,SAAS,CAACgB,WAAW,EAAE9C,KAAK,CAACgC,GAAG,EAAEC,KAAK,EAAEC,QAAQ,CAAC;AAC3D;AACA,SAASa,oBAAoBA,CAAC/C,KAAK,EAAE4C,IAAI,EAAEC,MAAM,EAAE;EACjD,MAAMC,WAAW,GAAGP,eAAe,CAACvC,KAAK,EAAE6C,MAAM,CAAC;EAClD,IAAIC,WAAW,KAAKjE,SAAS,EAAE;IAC7B,OAAO;MAACmD,GAAG,EAAEhC,KAAK,CAACgC,GAAG;MAAEK,GAAG,EAAErC,KAAK,CAACqC;IAAG,CAAC;EACzC;EACA,MAAMW,MAAM,GAAGZ,IAAI,CAACa,KAAK,CAACjD,KAAK,CAACgC,GAAG,CAAC;EACpC,MAAMkB,MAAM,GAAGd,IAAI,CAACa,KAAK,CAACjD,KAAK,CAACqC,GAAG,CAAC;EACpC,MAAMc,SAAS,GAAGf,IAAI,CAACa,KAAK,CAACH,WAAW,CAAC;EACzC,MAAMM,QAAQ,GAAGF,MAAM,GAAGF,MAAM;EAChC,MAAMK,WAAW,GAAGD,QAAQ,IAAIR,IAAI,GAAG,CAAC,CAAC;EACzC,MAAMU,KAAK,GAAGxB,SAAS,CAACqB,SAAS,EAAEH,MAAM,EAAEI,QAAQ,EAAEC,WAAW,CAAC;EACjE,OAAO;IACLrB,GAAG,EAAEI,IAAI,CAACmB,GAAG,CAAC,EAAE,EAAEP,MAAM,GAAGM,KAAK,CAACtB,GAAG,CAAC;IACrCK,GAAG,EAAED,IAAI,CAACmB,GAAG,CAAC,EAAE,EAAEL,MAAM,GAAGI,KAAK,CAACjB,GAAG;EACtC,CAAC;AACH;AACA,SAASmB,cAAcA,CAACxD,KAAK,EAAEyD,MAAM,EAAE;EACrC,OAAOA,MAAM,KAAKA,MAAM,CAACzD,KAAK,CAAC0D,EAAE,CAAC,IAAID,MAAM,CAACzD,KAAK,CAACY,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AACjE;AACA,SAAS+C,QAAQA,CAACxC,KAAK,EAAEnB,KAAK,EAAE4D,WAAW,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EAC3D,IAAIC,KAAK,GAAGH,WAAW,CAACC,IAAI,CAAC;EAC7B,IAAIE,KAAK,KAAK,UAAU,EAAE;IACxB,MAAMC,QAAQ,GAAG7C,KAAK,CAACE,mBAAmB,CAACrB,KAAK,CAAC0D,EAAE,CAAC,CAACG,IAAI,CAAC;IAC1DE,KAAK,GAAGpG,cAAc,CAACqG,QAAQ,CAAC1D,OAAO,EAAE0D,QAAQ,CAAChE,KAAK,CAAC;EAC1D;EACA,OAAOrC,cAAc,CAACoG,KAAK,EAAED,QAAQ,CAAC;AACxC;AACA,SAASG,WAAWA,CAACjE,KAAK,EAAEkE,MAAM,EAAEC,MAAM,EAAE;EAC1C,MAAMC,EAAE,GAAGpE,KAAK,CAAC0C,gBAAgB,CAACwB,MAAM,CAAC;EACzC,MAAMG,EAAE,GAAGrE,KAAK,CAAC0C,gBAAgB,CAACyB,MAAM,CAAC;EACzC,OAAO;IACLnC,GAAG,EAAEI,IAAI,CAACJ,GAAG,CAACoC,EAAE,EAAEC,EAAE,CAAC;IACrBhC,GAAG,EAAED,IAAI,CAACC,GAAG,CAAC+B,EAAE,EAAEC,EAAE;EACtB,CAAC;AACH;AACA,SAASC,QAAQA,CAACrC,KAAK,EAAAsC,KAAA,EAAkCC,cAAc,EAAE;EAAA,IAAhD;IAACxC,GAAG;IAAEK,GAAG;IAAEoC,QAAQ;IAAEC;EAAQ,CAAC,GAAAH,KAAA;EACrD,MAAMI,MAAM,GAAG,CAAC1C,KAAK,GAAGI,GAAG,GAAGL,GAAG,IAAI,CAAC;EACtCA,GAAG,IAAI2C,MAAM;EACbtC,GAAG,IAAIsC,MAAM;EACb,MAAMC,OAAO,GAAGJ,cAAc,CAACxC,GAAG,CAAC1B,OAAO,IAAIkE,cAAc,CAACxC,GAAG,CAAChC,KAAK;EACtE,MAAM6E,OAAO,GAAGL,cAAc,CAACnC,GAAG,CAAC/B,OAAO,IAAIkE,cAAc,CAACnC,GAAG,CAACrC,KAAK;EACtE,MAAM8E,OAAO,GAAG7C,KAAK,GAAG,GAAG;EAC3B,IAAIrE,YAAY,CAACoE,GAAG,EAAE4C,OAAO,EAAEE,OAAO,CAAC,EAAE;IACvC9C,GAAG,GAAG4C,OAAO;EACf;EACA,IAAIhH,YAAY,CAACyE,GAAG,EAAEwC,OAAO,EAAEC,OAAO,CAAC,EAAE;IACvCzC,GAAG,GAAGwC,OAAO;EACf;EACA,IAAI7C,GAAG,GAAGyC,QAAQ,EAAE;IAClBzC,GAAG,GAAGyC,QAAQ;IACdpC,GAAG,GAAGD,IAAI,CAACJ,GAAG,CAACyC,QAAQ,GAAGxC,KAAK,EAAEyC,QAAQ,CAAC;EAC5C,CAAC,MAAM,IAAIrC,GAAG,GAAGqC,QAAQ,EAAE;IACzBrC,GAAG,GAAGqC,QAAQ;IACd1C,GAAG,GAAGI,IAAI,CAACC,GAAG,CAACqC,QAAQ,GAAGzC,KAAK,EAAEwC,QAAQ,CAAC;EAC5C;EACA,OAAO;IAACzC,GAAG;IAAEK;EAAG,CAAC;AACnB;AACA,SAAS0C,WAAWA,CAAC/E,KAAK,EAAAgF,KAAA,EAAcvB,MAAM,EAAgB;EAAA,IAAlC;IAACzB,GAAG;IAAEK;EAAG,CAAC,GAAA2C,KAAA;EAAA,IAAUpC,IAAI,GAAAqC,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAApG,SAAA,GAAAoG,SAAA,MAAG,KAAK;EAC1D,MAAM9D,KAAK,GAAGD,QAAQ,CAAClB,KAAK,CAACpB,KAAK,CAAC;EACnC,MAAM;IAAC0B,OAAO,EAAE4E;EAAS,CAAC,GAAGlF,KAAK;EAClC,MAAM4D,WAAW,GAAGJ,cAAc,CAACxD,KAAK,EAAEyD,MAAM,CAAC;EACjD,MAAM;IAAC0B,QAAQ,GAAG;EAAC,CAAC,GAAGvB,WAAW;EAClC,MAAMa,QAAQ,GAAGd,QAAQ,CAACxC,KAAK,EAAEnB,KAAK,EAAE4D,WAAW,EAAE,KAAK,EAAE,CAACwB,QAAQ,CAAC;EACtE,MAAMV,QAAQ,GAAGf,QAAQ,CAACxC,KAAK,EAAEnB,KAAK,EAAE4D,WAAW,EAAE,KAAK,EAAEwB,QAAQ,CAAC;EACrE,IAAIxC,IAAI,KAAK,KAAK,KAAKZ,GAAG,GAAGyC,QAAQ,IAAIpC,GAAG,GAAGqC,QAAQ,CAAC,EAAE;IACxD,OAAO,IAAI;EACb;EACA,MAAMW,UAAU,GAAGrF,KAAK,CAACqC,GAAG,GAAGrC,KAAK,CAACgC,GAAG;EACxC,MAAMC,KAAK,GAAGW,IAAI,GAAGR,IAAI,CAACC,GAAG,CAACA,GAAG,GAAGL,GAAG,EAAEmD,QAAQ,CAAC,GAAGE,UAAU;EAC/D,IAAIzC,IAAI,IAAIX,KAAK,KAAKkD,QAAQ,IAAIE,UAAU,IAAIF,QAAQ,EAAE;IACxD,OAAO,IAAI;EACb;EACA,MAAMjD,QAAQ,GAAGoC,QAAQ,CAACrC,KAAK,EAAE;IAACD,GAAG;IAAEK,GAAG;IAAEoC,QAAQ;IAAEC;EAAQ,CAAC,EAAEvD,KAAK,CAACE,mBAAmB,CAACrB,KAAK,CAAC0D,EAAE,CAAC,CAAC;EACrGwB,SAAS,CAAClD,GAAG,GAAGE,QAAQ,CAACF,GAAG;EAC5BkD,SAAS,CAAC7C,GAAG,GAAGH,QAAQ,CAACG,GAAG;EAC5BlB,KAAK,CAACG,kBAAkB,CAACtB,KAAK,CAAC0D,EAAE,CAAC,GAAGxB,QAAQ;EAC7C,OAAOlC,KAAK,CAACsF,KAAK,CAACpD,QAAQ,CAACF,GAAG,CAAC,KAAKhC,KAAK,CAACgC,GAAG,IAAIhC,KAAK,CAACsF,KAAK,CAACpD,QAAQ,CAACG,GAAG,CAAC,KAAKrC,KAAK,CAACqC,GAAG;AAC3F;AACA,SAASkD,kBAAkBA,CAACvF,KAAK,EAAE4C,IAAI,EAAEC,MAAM,EAAEY,MAAM,EAAE;EACvD,MAAMH,KAAK,GAAGX,eAAe,CAAC3C,KAAK,EAAE4C,IAAI,EAAEC,MAAM,CAAC;EAClD,MAAMX,QAAQ,GAAG;IAACF,GAAG,EAAEhC,KAAK,CAACgC,GAAG,GAAGsB,KAAK,CAACtB,GAAG;IAAEK,GAAG,EAAErC,KAAK,CAACqC,GAAG,GAAGiB,KAAK,CAACjB;EAAG,CAAC;EACzE,OAAO0C,WAAW,CAAC/E,KAAK,EAAEkC,QAAQ,EAAEuB,MAAM,EAAE,IAAI,CAAC;AACnD;AACA,SAAS+B,oBAAoBA,CAACxF,KAAK,EAAE4C,IAAI,EAAEC,MAAM,EAAEY,MAAM,EAAE;EACzD,MAAMvB,QAAQ,GAAGa,oBAAoB,CAAC/C,KAAK,EAAE4C,IAAI,EAAEC,MAAM,CAAC;EAC1D,OAAOkC,WAAW,CAAC/E,KAAK,EAAEkC,QAAQ,EAAEuB,MAAM,EAAE,IAAI,CAAC;AACnD;AACA,SAASgC,sBAAsBA,CAACzF,KAAK,EAAE0F,IAAI,EAAEC,EAAE,EAAElC,MAAM,EAAE;EACvDsB,WAAW,CAAC/E,KAAK,EAAEiE,WAAW,CAACjE,KAAK,EAAE0F,IAAI,EAAEC,EAAE,CAAC,EAAElC,MAAM,EAAE,IAAI,CAAC;AAChE;AACA,MAAMmC,aAAa,GAAIC,CAAC,IAAKA,CAAC,KAAK,CAAC,IAAIC,KAAK,CAACD,CAAC,CAAC,GAAG,CAAC,GAAGA,CAAC,GAAG,CAAC,GAAGzD,IAAI,CAACJ,GAAG,CAACI,IAAI,CAAC2D,KAAK,CAACF,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAGzD,IAAI,CAACC,GAAG,CAACD,IAAI,CAAC2D,KAAK,CAACF,CAAC,CAAC,EAAE,CAAC,CAAC;AACvH,SAASG,wBAAwBA,CAAChG,KAAK,EAAE;EACvC,MAAMiG,MAAM,GAAGjG,KAAK,CAACkG,SAAS,CAAC,CAAC;EAChC,MAAMC,QAAQ,GAAGF,MAAM,CAAClG,MAAM,GAAG,CAAC;EAClC,IAAIC,KAAK,CAACgC,GAAG,GAAG,CAAC,EAAE;IACjBhC,KAAK,CAACgC,GAAG,IAAI,CAAC;EAChB;EACA,IAAIhC,KAAK,CAACqC,GAAG,GAAG8D,QAAQ,EAAE;IACxBnG,KAAK,CAACqC,GAAG,IAAI,CAAC;EAChB;AACF;AACA,SAAS+D,iBAAiBA,CAACpG,KAAK,EAAE4C,IAAI,EAAEC,MAAM,EAAEY,MAAM,EAAE;EACtD,MAAMH,KAAK,GAAGX,eAAe,CAAC3C,KAAK,EAAE4C,IAAI,EAAEC,MAAM,CAAC;EAClD,IAAI7C,KAAK,CAACgC,GAAG,KAAKhC,KAAK,CAACqC,GAAG,IAAIO,IAAI,GAAG,CAAC,EAAE;IACvCoD,wBAAwB,CAAChG,KAAK,CAAC;EACjC;EACA,MAAMkC,QAAQ,GAAG;IAACF,GAAG,EAAEhC,KAAK,CAACgC,GAAG,GAAG4D,aAAa,CAACtC,KAAK,CAACtB,GAAG,CAAC;IAAEK,GAAG,EAAErC,KAAK,CAACqC,GAAG,GAAGuD,aAAa,CAACtC,KAAK,CAACjB,GAAG;EAAC,CAAC;EACvG,OAAO0C,WAAW,CAAC/E,KAAK,EAAEkC,QAAQ,EAAEuB,MAAM,EAAE,IAAI,CAAC;AACnD;AACA,SAAS4C,WAAWA,CAACrG,KAAK,EAAE;EAC1B,OAAOA,KAAK,CAACyC,YAAY,CAAC,CAAC,GAAGzC,KAAK,CAACsG,KAAK,GAAGtG,KAAK,CAACuG,MAAM;AAC1D;AACA,SAASC,gBAAgBA,CAACxG,KAAK,EAAEsD,KAAK,EAAEG,MAAM,EAAE;EAC9C,MAAMwC,MAAM,GAAGjG,KAAK,CAACkG,SAAS,CAAC,CAAC;EAChC,MAAMO,cAAc,GAAGR,MAAM,CAAClG,MAAM,GAAG,CAAC;EACxC,IAAI;IAACiC,GAAG;IAAEK;EAAG,CAAC,GAAGrC,KAAK;EACtB,MAAMiC,KAAK,GAAGG,IAAI,CAACC,GAAG,CAACA,GAAG,GAAGL,GAAG,EAAE,CAAC,CAAC;EACpC,MAAM0E,SAAS,GAAGtE,IAAI,CAAC2D,KAAK,CAACM,WAAW,CAACrG,KAAK,CAAC,GAAGoC,IAAI,CAACC,GAAG,CAACJ,KAAK,EAAE,EAAE,CAAC,CAAC;EACtE,MAAM0E,QAAQ,GAAGvE,IAAI,CAAC2D,KAAK,CAAC3D,IAAI,CAACwE,GAAG,CAACtD,KAAK,GAAGoD,SAAS,CAAC,CAAC;EACxD,IAAIG,OAAO;EACX,IAAIvD,KAAK,GAAG,CAACoD,SAAS,EAAE;IACtBrE,GAAG,GAAGD,IAAI,CAACJ,GAAG,CAACK,GAAG,GAAGsE,QAAQ,EAAEF,cAAc,CAAC;IAC9CzE,GAAG,GAAGC,KAAK,KAAK,CAAC,GAAGI,GAAG,GAAGA,GAAG,GAAGJ,KAAK;IACrC4E,OAAO,GAAGxE,GAAG,KAAKoE,cAAc;EAClC,CAAC,MAAM,IAAInD,KAAK,GAAGoD,SAAS,EAAE;IAC5B1E,GAAG,GAAGI,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEL,GAAG,GAAG2E,QAAQ,CAAC;IACjCtE,GAAG,GAAGJ,KAAK,KAAK,CAAC,GAAGD,GAAG,GAAGA,GAAG,GAAGC,KAAK;IACrC4E,OAAO,GAAG7E,GAAG,KAAK,CAAC;EACrB;EACA,OAAO+C,WAAW,CAAC/E,KAAK,EAAE;IAACgC,GAAG;IAAEK;EAAG,CAAC,EAAEoB,MAAM,CAAC,IAAIoD,OAAO;AAC1D;AACA,MAAMC,OAAO,GAAG;EACdC,MAAM,EAAE,GAAG;EACXC,MAAM,EAAE,EAAE,GAAG,IAAI;EACjBC,IAAI,EAAE,EAAE,GAAG,EAAE,GAAG,IAAI;EACpBC,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;EACxBC,IAAI,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;EAC/BC,KAAK,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;EAC/BC,OAAO,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;EACjCC,IAAI,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;AAC7B,CAAC;AACD,SAASC,iBAAiBA,CAACvH,KAAK,EAAEsD,KAAK,EAAEG,MAAM,EAAe;EAAA,IAAb+D,GAAG,GAAAvC,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAApG,SAAA,GAAAoG,SAAA,MAAG,KAAK;EAC1D,MAAM;IAACjD,GAAG,EAAEyF,SAAS;IAAEpF,GAAG,EAAEqF,OAAO;IAAEpH;EAAO,CAAC,GAAGN,KAAK;EACrD,MAAM+F,KAAK,GAAGzF,OAAO,CAACqH,IAAI,IAAIrH,OAAO,CAACqH,IAAI,CAAC5B,KAAK;EAChD,MAAMpB,MAAM,GAAGmC,OAAO,CAACf,KAAK,CAAC,IAAI,CAAC;EAClC,MAAM6B,MAAM,GAAG5H,KAAK,CAAC0C,gBAAgB,CAAC1C,KAAK,CAAC6H,gBAAgB,CAACJ,SAAS,GAAG9C,MAAM,CAAC,GAAGrB,KAAK,CAAC;EACzF,MAAMwE,MAAM,GAAG9H,KAAK,CAAC0C,gBAAgB,CAAC1C,KAAK,CAAC6H,gBAAgB,CAACH,OAAO,GAAG/C,MAAM,CAAC,GAAGrB,KAAK,CAAC;EACvF,IAAIwC,KAAK,CAAC8B,MAAM,CAAC,IAAI9B,KAAK,CAACgC,MAAM,CAAC,EAAE;IAClC,OAAO,IAAI;EACb;EACA,OAAO/C,WAAW,CAAC/E,KAAK,EAAE;IAACgC,GAAG,EAAE4F,MAAM;IAAEvF,GAAG,EAAEyF;EAAM,CAAC,EAAErE,MAAM,EAAE+D,GAAG,GAAG,KAAK,GAAG,KAAK,CAAC;AACpF;AACA,SAASO,iBAAiBA,CAAC/H,KAAK,EAAEsD,KAAK,EAAEG,MAAM,EAAE;EAC/C,OAAO8D,iBAAiB,CAACvH,KAAK,EAAEsD,KAAK,EAAEG,MAAM,EAAE,IAAI,CAAC;AACtD;AACA,MAAMuE,aAAa,GAAG;EACpBC,QAAQ,EAAE7B,iBAAiB;EAC3B8B,OAAO,EAAE3C,kBAAkB;EAC3B4C,WAAW,EAAE3C;AACf,CAAC;AACD,MAAM4C,iBAAiB,GAAG;EACxBF,OAAO,EAAEzC;AACX,CAAC;AACD,MAAM4C,YAAY,GAAG;EACnBJ,QAAQ,EAAEzB,gBAAgB;EAC1B0B,OAAO,EAAEX,iBAAiB;EAC1BY,WAAW,EAAEJ,iBAAiB;EAC9BO,UAAU,EAAEP;AACd,CAAC;AAED,SAASQ,uBAAuBA,CAACvI,KAAK,EAAEqB,mBAAmB,EAAEC,kBAAkB,EAAE;EAC/E,MAAM;IAACoC,EAAE;IAAEpD,OAAO,EAAE;MAAC0B,GAAG;MAAEK;IAAG;EAAC,CAAC,GAAGrC,KAAK;EACvC,IAAI,CAACqB,mBAAmB,CAACqC,EAAE,CAAC,IAAI,CAACpC,kBAAkB,CAACoC,EAAE,CAAC,EAAE;IACvD,OAAO,IAAI;EACb;EACA,MAAM8E,QAAQ,GAAGlH,kBAAkB,CAACoC,EAAE,CAAC;EACvC,OAAO8E,QAAQ,CAACxG,GAAG,KAAKA,GAAG,IAAIwG,QAAQ,CAACnG,GAAG,KAAKA,GAAG;AACrD;AACA,SAASoG,mBAAmBA,CAAChF,MAAM,EAAE/D,MAAM,EAAE;EAC3ChC,IAAI,CAAC+F,MAAM,EAAE,CAACiF,GAAG,EAAEpK,GAAG,KAAK;IACzB,IAAI,CAACoB,MAAM,CAACpB,GAAG,CAAC,EAAE;MAChB,OAAOmF,MAAM,CAACnF,GAAG,CAAC;IACpB;EACF,CAAC,CAAC;AACJ;AACA,SAASqK,wBAAwBA,CAAC/J,KAAK,EAAEuC,KAAK,EAAE;EAC9C,MAAM;IAACzB;EAAM,CAAC,GAAGd,KAAK;EACtB,MAAM;IAACyC,mBAAmB;IAAEC;EAAkB,CAAC,GAAGH,KAAK;EACvDzD,IAAI,CAACgC,MAAM,EAAE,UAASM,KAAK,EAAE;IAC3B,IAAIuI,uBAAuB,CAACvI,KAAK,EAAEqB,mBAAmB,EAAEC,kBAAkB,CAAC,EAAE;MAC3ED,mBAAmB,CAACrB,KAAK,CAAC0D,EAAE,CAAC,GAAG;QAC9B1B,GAAG,EAAE;UAAChC,KAAK,EAAEA,KAAK,CAACgC,GAAG;UAAE1B,OAAO,EAAEN,KAAK,CAACM,OAAO,CAAC0B;QAAG,CAAC;QACnDK,GAAG,EAAE;UAACrC,KAAK,EAAEA,KAAK,CAACqC,GAAG;UAAE/B,OAAO,EAAEN,KAAK,CAACM,OAAO,CAAC+B;QAAG;MACpD,CAAC;IACH;EACF,CAAC,CAAC;EACFoG,mBAAmB,CAACpH,mBAAmB,EAAE3B,MAAM,CAAC;EAChD+I,mBAAmB,CAACnH,kBAAkB,EAAE5B,MAAM,CAAC;EAC/C,OAAO2B,mBAAmB;AAC5B;AACA,SAASuH,MAAMA,CAAC5I,KAAK,EAAE6I,MAAM,EAAEhG,MAAM,EAAEY,MAAM,EAAE;EAC7C,MAAMtE,EAAE,GAAG6I,aAAa,CAAChI,KAAK,CAAC8I,IAAI,CAAC,IAAId,aAAa,CAACE,OAAO;EAC7DrK,QAAQ,CAACsB,EAAE,EAAE,CAACa,KAAK,EAAE6I,MAAM,EAAEhG,MAAM,EAAEY,MAAM,CAAC,CAAC;AAC/C;AACA,SAASsF,UAAUA,CAAC/I,KAAK,EAAE0F,IAAI,EAAEC,EAAE,EAAElC,MAAM,EAAE;EAC3C,MAAMtE,EAAE,GAAGiJ,iBAAiB,CAACpI,KAAK,CAAC8I,IAAI,CAAC,IAAIV,iBAAiB,CAACF,OAAO;EACrErK,QAAQ,CAACsB,EAAE,EAAE,CAACa,KAAK,EAAE0F,IAAI,EAAEC,EAAE,EAAElC,MAAM,CAAC,CAAC;AACzC;AACA,SAASuF,SAASA,CAACpK,KAAK,EAAE;EACxB,MAAMqK,EAAE,GAAGrK,KAAK,CAACsK,SAAS;EAC1B,OAAO;IACLlK,CAAC,EAAE,CAACiK,EAAE,CAAC9I,IAAI,GAAG8I,EAAE,CAAC7I,KAAK,IAAI,CAAC;IAC3BnB,CAAC,EAAE,CAACgK,EAAE,CAAChJ,GAAG,GAAGgJ,EAAE,CAAC/I,MAAM,IAAI;EAC5B,CAAC;AACH;AACA,SAAS0C,IAAIA,CAAChE,KAAK,EAAEiK,MAAM,EAAwC;EAAA,IAAtCM,UAAU,GAAAlE,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAApG,SAAA,GAAAoG,SAAA,MAAG,MAAM;EAAA,IAAEmE,OAAO,GAAAnE,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAApG,SAAA,GAAAoG,SAAA,MAAG,KAAK;EAC/D,MAAM;IAACjG,CAAC,GAAG,CAAC;IAAEC,CAAC,GAAG,CAAC;IAAEoK,UAAU,GAAGL,SAAS,CAACpK,KAAK;EAAC,CAAC,GAAG,OAAOiK,MAAM,KAAK,QAAQ,GAAG;IAAC7J,CAAC,EAAE6J,MAAM;IAAE5J,CAAC,EAAE4J;EAAM,CAAC,GAAGA,MAAM;EAClH,MAAM1H,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,MAAM;IAAC0B,OAAO,EAAE;MAACmD,MAAM;MAAEb,IAAI,EAAE0G;IAAW;EAAC,CAAC,GAAGnI,KAAK;EACpDwH,wBAAwB,CAAC/J,KAAK,EAAEuC,KAAK,CAAC;EACtC,MAAMoI,QAAQ,GAAGvK,CAAC,KAAK,CAAC;EACxB,MAAMwK,QAAQ,GAAGvK,CAAC,KAAK,CAAC;EACxB,MAAM4B,aAAa,GAAGR,uBAAuB,CAACiJ,WAAW,EAAED,UAAU,EAAEzK,KAAK,CAAC;EAC7ElB,IAAI,CAACmD,aAAa,IAAIjC,KAAK,CAACc,MAAM,EAAE,UAASM,KAAK,EAAE;IAClD,IAAIA,KAAK,CAACyC,YAAY,CAAC,CAAC,IAAI8G,QAAQ,EAAE;MACpCX,MAAM,CAAC5I,KAAK,EAAEhB,CAAC,EAAEqK,UAAU,EAAE5F,MAAM,CAAC;IACtC,CAAC,MAAM,IAAI,CAACzD,KAAK,CAACyC,YAAY,CAAC,CAAC,IAAI+G,QAAQ,EAAE;MAC5CZ,MAAM,CAAC5I,KAAK,EAAEf,CAAC,EAAEoK,UAAU,EAAE5F,MAAM,CAAC;IACtC;EACF,CAAC,CAAC;EACF7E,KAAK,CAAC6K,MAAM,CAACN,UAAU,CAAC;EACxBtL,QAAQ,CAACyL,WAAW,CAACI,MAAM,EAAE,CAAC;IAAC9K,KAAK;IAAEwK;EAAO,CAAC,CAAC,CAAC;AAClD;AACA,SAASO,QAAQA,CAAC/K,KAAK,EAAEgL,EAAE,EAAEC,EAAE,EAAwC;EAAA,IAAtCV,UAAU,GAAAlE,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAApG,SAAA,GAAAoG,SAAA,MAAG,MAAM;EAAA,IAAEmE,OAAO,GAAAnE,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAApG,SAAA,GAAAoG,SAAA,MAAG,KAAK;EACnE,MAAM9D,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,MAAM;IAAC0B,OAAO,EAAE;MAACmD,MAAM;MAAEb,IAAI,EAAE0G;IAAW;EAAC,CAAC,GAAGnI,KAAK;EACpD,MAAM;IAACzC,IAAI,GAAG;EAAI,CAAC,GAAG4K,WAAW;EACjCX,wBAAwB,CAAC/J,KAAK,EAAEuC,KAAK,CAAC;EACtC,MAAMoI,QAAQ,GAAG9K,gBAAgB,CAACC,IAAI,EAAE,GAAG,EAAEE,KAAK,CAAC;EACnD,MAAM4K,QAAQ,GAAG/K,gBAAgB,CAACC,IAAI,EAAE,GAAG,EAAEE,KAAK,CAAC;EACnDlB,IAAI,CAACkB,KAAK,CAACc,MAAM,EAAE,UAASM,KAAK,EAAE;IACjC,IAAIA,KAAK,CAACyC,YAAY,CAAC,CAAC,IAAI8G,QAAQ,EAAE;MACpCR,UAAU,CAAC/I,KAAK,EAAE4J,EAAE,CAAC5K,CAAC,EAAE6K,EAAE,CAAC7K,CAAC,EAAEyE,MAAM,CAAC;IACvC,CAAC,MAAM,IAAI,CAACzD,KAAK,CAACyC,YAAY,CAAC,CAAC,IAAI+G,QAAQ,EAAE;MAC5CT,UAAU,CAAC/I,KAAK,EAAE4J,EAAE,CAAC3K,CAAC,EAAE4K,EAAE,CAAC5K,CAAC,EAAEwE,MAAM,CAAC;IACvC;EACF,CAAC,CAAC;EACF7E,KAAK,CAAC6K,MAAM,CAACN,UAAU,CAAC;EACxBtL,QAAQ,CAACyL,WAAW,CAACI,MAAM,EAAE,CAAC;IAAC9K,KAAK;IAAEwK;EAAO,CAAC,CAAC,CAAC;AAClD;AACA,SAASU,SAASA,CAAClL,KAAK,EAAEmL,OAAO,EAAE9H,KAAK,EAAwC;EAAA,IAAtCkH,UAAU,GAAAlE,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAApG,SAAA,GAAAoG,SAAA,MAAG,MAAM;EAAA,IAAEmE,OAAO,GAAAnE,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAApG,SAAA,GAAAoG,SAAA,MAAG,KAAK;EAC5E,MAAM9D,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B+J,wBAAwB,CAAC/J,KAAK,EAAEuC,KAAK,CAAC;EACtC,MAAMnB,KAAK,GAAGpB,KAAK,CAACc,MAAM,CAACqK,OAAO,CAAC;EACnChF,WAAW,CAAC/E,KAAK,EAAEiC,KAAK,EAAEpD,SAAS,EAAE,IAAI,CAAC;EAC1CD,KAAK,CAAC6K,MAAM,CAACN,UAAU,CAAC;EACxBtL,QAAQ,CAACsD,KAAK,CAACb,OAAO,CAACsC,IAAI,EAAE8G,MAAM,EAAE,CAAC;IAAC9K,KAAK;IAAEwK;EAAO,CAAC,CAAC,CAAC;AAC1D;AACA,SAASY,SAASA,CAACpL,KAAK,EAA0B;EAAA,IAAxBuK,UAAU,GAAAlE,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAApG,SAAA,GAAAoG,SAAA,MAAG,SAAS;EAC9C,MAAM9D,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,MAAMyC,mBAAmB,GAAGsH,wBAAwB,CAAC/J,KAAK,EAAEuC,KAAK,CAAC;EAClEzD,IAAI,CAACkB,KAAK,CAACc,MAAM,EAAE,UAASM,KAAK,EAAE;IACjC,MAAMiK,YAAY,GAAGjK,KAAK,CAACM,OAAO;IAClC,IAAIe,mBAAmB,CAACrB,KAAK,CAAC0D,EAAE,CAAC,EAAE;MACjCuG,YAAY,CAACjI,GAAG,GAAGX,mBAAmB,CAACrB,KAAK,CAAC0D,EAAE,CAAC,CAAC1B,GAAG,CAAC1B,OAAO;MAC5D2J,YAAY,CAAC5H,GAAG,GAAGhB,mBAAmB,CAACrB,KAAK,CAAC0D,EAAE,CAAC,CAACrB,GAAG,CAAC/B,OAAO;IAC9D,CAAC,MAAM;MACL,OAAO2J,YAAY,CAACjI,GAAG;MACvB,OAAOiI,YAAY,CAAC5H,GAAG;IACzB;IACA,OAAOlB,KAAK,CAACG,kBAAkB,CAACtB,KAAK,CAAC0D,EAAE,CAAC;EAC3C,CAAC,CAAC;EACF9E,KAAK,CAAC6K,MAAM,CAACN,UAAU,CAAC;EACxBtL,QAAQ,CAACsD,KAAK,CAACb,OAAO,CAACsC,IAAI,CAACsH,cAAc,EAAE,CAAC;IAACtL;EAAK,CAAC,CAAC,CAAC;AACxD;AACA,SAASuL,gBAAgBA,CAAChJ,KAAK,EAAE4I,OAAO,EAAE;EACxC,MAAM/F,QAAQ,GAAG7C,KAAK,CAACE,mBAAmB,CAAC0I,OAAO,CAAC;EACnD,IAAI,CAAC/F,QAAQ,EAAE;IACb;EACF;EACA,MAAM;IAAChC,GAAG;IAAEK;EAAG,CAAC,GAAG2B,QAAQ;EAC3B,OAAOrG,cAAc,CAAC0E,GAAG,CAAC/B,OAAO,EAAE+B,GAAG,CAACrC,KAAK,CAAC,GAAGrC,cAAc,CAACqE,GAAG,CAAC1B,OAAO,EAAE0B,GAAG,CAAChC,KAAK,CAAC;AACxF;AACA,SAASoK,YAAYA,CAACxL,KAAK,EAAE;EAC3B,MAAMuC,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,IAAIoD,GAAG,GAAG,CAAC;EACX,IAAIK,GAAG,GAAG,CAAC;EACX3E,IAAI,CAACkB,KAAK,CAACc,MAAM,EAAE,UAASM,KAAK,EAAE;IACjC,MAAMqK,SAAS,GAAGF,gBAAgB,CAAChJ,KAAK,EAAEnB,KAAK,CAAC0D,EAAE,CAAC;IACnD,IAAI2G,SAAS,EAAE;MACb,MAAMC,KAAK,GAAGlI,IAAI,CAAC2D,KAAK,CAACsE,SAAS,IAAIrK,KAAK,CAACqC,GAAG,GAAGrC,KAAK,CAACgC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG;MACzEA,GAAG,GAAGI,IAAI,CAACJ,GAAG,CAACA,GAAG,EAAEsI,KAAK,CAAC;MAC1BjI,GAAG,GAAGD,IAAI,CAACC,GAAG,CAACA,GAAG,EAAEiI,KAAK,CAAC;IAC5B;EACF,CAAC,CAAC;EACF,OAAOtI,GAAG,GAAG,CAAC,GAAGA,GAAG,GAAGK,GAAG;AAC5B;AACA,SAASkI,QAAQA,CAACvK,KAAK,EAAEsD,KAAK,EAAEG,MAAM,EAAEtC,KAAK,EAAE;EAC7C,MAAM;IAACK;EAAQ,CAAC,GAAGL,KAAK;EACxB,MAAMqJ,WAAW,GAAGhJ,QAAQ,CAACxB,KAAK,CAAC0D,EAAE,CAAC,IAAI,CAAC;EAC3C,IAAI5F,IAAI,CAAC0M,WAAW,CAAC,KAAK1M,IAAI,CAACwF,KAAK,CAAC,EAAE;IACrCA,KAAK,IAAIkH,WAAW;EACtB;EACA,MAAMrL,EAAE,GAAGkJ,YAAY,CAACrI,KAAK,CAAC8I,IAAI,CAAC,IAAIT,YAAY,CAACH,OAAO;EAC3D,IAAIrK,QAAQ,CAACsB,EAAE,EAAE,CAACa,KAAK,EAAEsD,KAAK,EAAEG,MAAM,CAAC,CAAC,EAAE;IACxCjC,QAAQ,CAACxB,KAAK,CAAC0D,EAAE,CAAC,GAAG,CAAC;EACxB,CAAC,MAAM;IACLlC,QAAQ,CAACxB,KAAK,CAAC0D,EAAE,CAAC,GAAGJ,KAAK;EAC5B;AACF;AACA,SAASkE,GAAGA,CAAC5I,KAAK,EAAE0E,KAAK,EAAEzC,aAAa,EAAuB;EAAA,IAArBsI,UAAU,GAAAlE,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAApG,SAAA,GAAAoG,SAAA,MAAG,MAAM;EAC3D,MAAM;IAACjG,CAAC,GAAG,CAAC;IAAEC,CAAC,GAAG;EAAC,CAAC,GAAG,OAAOqE,KAAK,KAAK,QAAQ,GAAG;IAACtE,CAAC,EAAEsE,KAAK;IAAErE,CAAC,EAAEqE;EAAK,CAAC,GAAGA,KAAK;EAC/E,MAAMnC,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,MAAM;IAAC0B,OAAO,EAAE;MAACkH,GAAG,EAAEiD,UAAU;MAAEhH;IAAM;EAAC,CAAC,GAAGtC,KAAK;EAClD,MAAM;IAACuJ;EAAK,CAAC,GAAGD,UAAU,IAAI,CAAC,CAAC;EAChC9B,wBAAwB,CAAC/J,KAAK,EAAEuC,KAAK,CAAC;EACtC,MAAMoI,QAAQ,GAAGvK,CAAC,KAAK,CAAC;EACxB,MAAMwK,QAAQ,GAAGvK,CAAC,KAAK,CAAC;EACxBvB,IAAI,CAACmD,aAAa,IAAIjC,KAAK,CAACc,MAAM,EAAE,UAASM,KAAK,EAAE;IAClD,IAAIA,KAAK,CAACyC,YAAY,CAAC,CAAC,IAAI8G,QAAQ,EAAE;MACpCgB,QAAQ,CAACvK,KAAK,EAAEhB,CAAC,EAAEyE,MAAM,EAAEtC,KAAK,CAAC;IACnC,CAAC,MAAM,IAAI,CAACnB,KAAK,CAACyC,YAAY,CAAC,CAAC,IAAI+G,QAAQ,EAAE;MAC5Ce,QAAQ,CAACvK,KAAK,EAAEf,CAAC,EAAEwE,MAAM,EAAEtC,KAAK,CAAC;IACnC;EACF,CAAC,CAAC;EACFvC,KAAK,CAAC6K,MAAM,CAACN,UAAU,CAAC;EACxBtL,QAAQ,CAAC6M,KAAK,EAAE,CAAC;IAAC9L;EAAK,CAAC,CAAC,CAAC;AAC5B;AACA,SAAS+L,qBAAqBA,CAAC/L,KAAK,EAAE;EACpC,MAAMuC,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B+J,wBAAwB,CAAC/J,KAAK,EAAEuC,KAAK,CAAC;EACtC,MAAMyJ,WAAW,GAAG,CAAC,CAAC;EACtB,KAAK,MAAMb,OAAO,IAAInK,MAAM,CAACC,IAAI,CAACjB,KAAK,CAACc,MAAM,CAAC,EAAE;IAC/C,MAAM;MAACsC,GAAG;MAAEK;IAAG,CAAC,GAAGlB,KAAK,CAACE,mBAAmB,CAAC0I,OAAO,CAAC,IAAI;MAAC/H,GAAG,EAAE,CAAC,CAAC;MAAEK,GAAG,EAAE,CAAC;IAAC,CAAC;IAC3EuI,WAAW,CAACb,OAAO,CAAC,GAAG;MAAC/H,GAAG,EAAEA,GAAG,CAAChC,KAAK;MAAEqC,GAAG,EAAEA,GAAG,CAACrC;IAAK,CAAC;EACzD;EACA,OAAO4K,WAAW;AACpB;AACA,SAASC,oBAAoBA,CAACjM,KAAK,EAAE;EACnC,MAAMuC,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,MAAMgM,WAAW,GAAG,CAAC,CAAC;EACtB,KAAK,MAAMb,OAAO,IAAInK,MAAM,CAACC,IAAI,CAACjB,KAAK,CAACc,MAAM,CAAC,EAAE;IAC/CkL,WAAW,CAACb,OAAO,CAAC,GAAG5I,KAAK,CAACG,kBAAkB,CAACyI,OAAO,CAAC;EAC1D;EACA,OAAOa,WAAW;AACpB;AACA,SAASE,gBAAgBA,CAAClM,KAAK,EAAE;EAC/B,MAAMgM,WAAW,GAAGD,qBAAqB,CAAC/L,KAAK,CAAC;EAChD,KAAK,MAAMmL,OAAO,IAAInK,MAAM,CAACC,IAAI,CAACjB,KAAK,CAACc,MAAM,CAAC,EAAE;IAC/C,MAAM;MAACsC,GAAG,EAAE+I,WAAW;MAAE1I,GAAG,EAAE2I;IAAW,CAAC,GAAGJ,WAAW,CAACb,OAAO,CAAC;IACjE,IAAIgB,WAAW,KAAKlM,SAAS,IAAID,KAAK,CAACc,MAAM,CAACqK,OAAO,CAAC,CAAC/H,GAAG,KAAK+I,WAAW,EAAE;MAC1E,OAAO,IAAI;IACb;IACA,IAAIC,WAAW,KAAKnM,SAAS,IAAID,KAAK,CAACc,MAAM,CAACqK,OAAO,CAAC,CAAC1H,GAAG,KAAK2I,WAAW,EAAE;MAC1E,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd;AACA,SAASC,kBAAkBA,CAACrM,KAAK,EAAE;EACjC,MAAMuC,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,OAAOuC,KAAK,CAACO,OAAO,IAAIP,KAAK,CAACM,QAAQ;AACxC;AAEA,MAAMyJ,KAAK,GAAGA,CAAClM,CAAC,EAAE0G,IAAI,EAAEC,EAAE,KAAKvD,IAAI,CAACJ,GAAG,CAAC2D,EAAE,EAAEvD,IAAI,CAACC,GAAG,CAACqD,IAAI,EAAE1G,CAAC,CAAC,CAAC;AAC9D,SAASmM,aAAaA,CAACvM,KAAK,EAAEkK,IAAI,EAAE;EAClC,MAAM;IAACvH;EAAQ,CAAC,GAAGL,QAAQ,CAACtC,KAAK,CAAC;EAClC,MAAMwM,OAAO,GAAG7J,QAAQ,CAACuH,IAAI,CAAC;EAC9B,IAAIsC,OAAO,IAAIA,OAAO,CAACC,MAAM,EAAE;IAC7BD,OAAO,CAACC,MAAM,CAACC,mBAAmB,CAACxC,IAAI,EAAEsC,OAAO,CAAC;IACjD,OAAO7J,QAAQ,CAACuH,IAAI,CAAC;EACvB;AACF;AACA,SAASyC,UAAUA,CAAC3M,KAAK,EAAEyM,MAAM,EAAEvC,IAAI,EAAEsC,OAAO,EAAE;EAChD,MAAM;IAAC7J,QAAQ;IAAEjB;EAAO,CAAC,GAAGY,QAAQ,CAACtC,KAAK,CAAC;EAC3C,MAAM4M,UAAU,GAAGjK,QAAQ,CAACuH,IAAI,CAAC;EACjC,IAAI0C,UAAU,IAAIA,UAAU,CAACH,MAAM,KAAKA,MAAM,EAAE;IAC9C;EACF;EACAF,aAAa,CAACvM,KAAK,EAAEkK,IAAI,CAAC;EAC1BvH,QAAQ,CAACuH,IAAI,CAAC,GAAIvK,KAAK,IAAK6M,OAAO,CAACxM,KAAK,EAAEL,KAAK,EAAE+B,OAAO,CAAC;EAC1DiB,QAAQ,CAACuH,IAAI,CAAC,CAACuC,MAAM,GAAGA,MAAM;EAC9B,MAAMI,OAAO,GAAG3C,IAAI,KAAK,OAAO,GAAG,KAAK,GAAGjK,SAAS;EACpDwM,MAAM,CAACK,gBAAgB,CAAC5C,IAAI,EAAEvH,QAAQ,CAACuH,IAAI,CAAC,EAAE;IAAC2C;EAAO,CAAC,CAAC;AAC1D;AACA,SAASE,SAASA,CAAC/M,KAAK,EAAEL,KAAK,EAAE;EAC/B,MAAM4C,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,IAAIuC,KAAK,CAACyK,SAAS,EAAE;IACnBzK,KAAK,CAACM,QAAQ,GAAG,IAAI;IACrBN,KAAK,CAAC0K,OAAO,GAAGtN,KAAK;IACrBK,KAAK,CAAC6K,MAAM,CAAC,MAAM,CAAC;EACtB;AACF;AACA,SAASqC,OAAOA,CAAClN,KAAK,EAAEL,KAAK,EAAE;EAC7B,MAAM4C,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,IAAI,CAACuC,KAAK,CAACyK,SAAS,IAAIrN,KAAK,CAACD,GAAG,KAAK,QAAQ,EAAE;IAC9C;EACF;EACA6M,aAAa,CAACvM,KAAK,EAAE,SAAS,CAAC;EAC/BuC,KAAK,CAACM,QAAQ,GAAG,KAAK;EACtBN,KAAK,CAACyK,SAAS,GAAGzK,KAAK,CAAC0K,OAAO,GAAG,IAAI;EACtCjN,KAAK,CAAC6K,MAAM,CAAC,MAAM,CAAC;AACtB;AACA,SAASsC,gBAAgBA,CAACxN,KAAK,EAAEK,KAAK,EAAE;EACtC,IAAIL,KAAK,CAAC8M,MAAM,KAAKzM,KAAK,CAACoN,MAAM,EAAE;IACjC,MAAMC,UAAU,GAAGrN,KAAK,CAACoN,MAAM,CAACE,qBAAqB,CAAC,CAAC;IACvD,OAAO;MACLlN,CAAC,EAAET,KAAK,CAAC4N,OAAO,GAAGF,UAAU,CAAC9L,IAAI;MAClClB,CAAC,EAAEV,KAAK,CAAC6N,OAAO,GAAGH,UAAU,CAAChM;IAChC,CAAC;EACH;EACA,OAAOlC,mBAAmB,CAACQ,KAAK,EAAEK,KAAK,CAAC;AAC1C;AACA,SAASyN,SAASA,CAACzN,KAAK,EAAEL,KAAK,EAAE+K,WAAW,EAAE;EAC5C,MAAM;IAACgD,WAAW;IAAEC;EAAc,CAAC,GAAGjD,WAAW;EACjD,IAAIgD,WAAW,EAAE;IACf,MAAM/L,KAAK,GAAGwL,gBAAgB,CAACxN,KAAK,EAAEK,KAAK,CAAC;IAC5C,IAAIf,QAAQ,CAACyO,WAAW,EAAE,CAAC;MAAC1N,KAAK;MAAEL,KAAK;MAAEgC;IAAK,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;MAC5D1C,QAAQ,CAAC0O,cAAc,EAAE,CAAC;QAAC3N,KAAK;QAAEL;MAAK,CAAC,CAAC,CAAC;MAC1C,OAAO,KAAK;IACd;EACF;AACF;AACA,SAASiO,SAASA,CAAC5N,KAAK,EAAEL,KAAK,EAAE;EAC/B,IAAIK,KAAK,CAAC6N,MAAM,EAAE;IAChB,MAAMlM,KAAK,GAAGxC,mBAAmB,CAACQ,KAAK,EAAEK,KAAK,CAAC;IAC/C,IAAIZ,cAAc,CAACuC,KAAK,EAAE3B,KAAK,CAAC6N,MAAM,CAAC,EAAE;MACvC;IACF;EACF;EACA,MAAMtL,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,MAAM;IAAC4I,GAAG,EAAEiD,UAAU;IAAE7H,IAAI,EAAE0G,WAAW,GAAG,CAAC;EAAC,CAAC,GAAGnI,KAAK,CAACb,OAAO;EAC/D,IACE/B,KAAK,CAACmO,MAAM,KAAK,CAAC,IAClBrO,UAAU,CAACJ,cAAc,CAACwM,UAAU,CAAC,EAAElM,KAAK,CAAC,IAC7CC,aAAa,CAACP,cAAc,CAACqL,WAAW,CAACqD,IAAI,CAAC,EAAEpO,KAAK,CAAC,EACtD;IACA,OAAOV,QAAQ,CAACyL,WAAW,CAACiD,cAAc,EAAE,CAAC;MAAC3N,KAAK;MAAEL;IAAK,CAAC,CAAC,CAAC;EAC/D;EACA,IAAI8N,SAAS,CAACzN,KAAK,EAAEL,KAAK,EAAE+K,WAAW,CAAC,KAAK,KAAK,EAAE;IAClD;EACF;EACAnI,KAAK,CAACyK,SAAS,GAAGrN,KAAK;EACvBgN,UAAU,CAAC3M,KAAK,EAAEA,KAAK,CAACoN,MAAM,CAACY,aAAa,EAAE,WAAW,EAAEjB,SAAS,CAAC;EACrEJ,UAAU,CAAC3M,KAAK,EAAEiO,MAAM,CAACC,QAAQ,EAAE,SAAS,EAAEhB,OAAO,CAAC;AACxD;AACA,SAASiB,gBAAgBA,CAAAC,KAAA,EAAeC,WAAW,EAAE;EAAA,IAA3B;IAACC,KAAK;IAAEC;EAAG,CAAC,GAAAH,KAAA;EACpC,IAAI1G,KAAK,GAAG6G,GAAG,CAACnO,CAAC,GAAGkO,KAAK,CAAClO,CAAC;EAC3B,IAAIuH,MAAM,GAAG4G,GAAG,CAAClO,CAAC,GAAGiO,KAAK,CAACjO,CAAC;EAC5B,MAAMmO,KAAK,GAAGhL,IAAI,CAACwE,GAAG,CAACN,KAAK,GAAGC,MAAM,CAAC;EACtC,IAAI6G,KAAK,GAAGH,WAAW,EAAE;IACvB3G,KAAK,GAAGlE,IAAI,CAACtE,IAAI,CAACwI,KAAK,CAAC,GAAGlE,IAAI,CAACwE,GAAG,CAACL,MAAM,GAAG0G,WAAW,CAAC;EAC3D,CAAC,MAAM,IAAIG,KAAK,GAAGH,WAAW,EAAE;IAC9B1G,MAAM,GAAGnE,IAAI,CAACtE,IAAI,CAACyI,MAAM,CAAC,GAAGnE,IAAI,CAACwE,GAAG,CAACN,KAAK,GAAG2G,WAAW,CAAC;EAC5D;EACAE,GAAG,CAACnO,CAAC,GAAGkO,KAAK,CAAClO,CAAC,GAAGsH,KAAK;EACvB6G,GAAG,CAAClO,CAAC,GAAGiO,KAAK,CAACjO,CAAC,GAAGsH,MAAM;AAC1B;AACA,SAAS8G,gBAAgBA,CAACC,IAAI,EAAEpE,SAAS,EAAEqE,MAAM,EAAAC,KAAA,EAAoB;EAAA,IAAlB;IAACxL,GAAG;IAAEK,GAAG;IAAEwB;EAAI,CAAC,GAAA2J,KAAA;EACjEF,IAAI,CAACtL,GAAG,CAAC,GAAGkJ,KAAK,CAAC9I,IAAI,CAACJ,GAAG,CAACuL,MAAM,CAACL,KAAK,CAACrJ,IAAI,CAAC,EAAE0J,MAAM,CAACJ,GAAG,CAACtJ,IAAI,CAAC,CAAC,EAAEqF,SAAS,CAAClH,GAAG,CAAC,EAAEkH,SAAS,CAAC7G,GAAG,CAAC,CAAC;EACjGiL,IAAI,CAACjL,GAAG,CAAC,GAAG6I,KAAK,CAAC9I,IAAI,CAACC,GAAG,CAACkL,MAAM,CAACL,KAAK,CAACrJ,IAAI,CAAC,EAAE0J,MAAM,CAACJ,GAAG,CAACtJ,IAAI,CAAC,CAAC,EAAEqF,SAAS,CAAClH,GAAG,CAAC,EAAEkH,SAAS,CAAC7G,GAAG,CAAC,CAAC;AACnG;AACA,SAASoL,iBAAiBA,CAAC7O,KAAK,EAAE8O,WAAW,EAAEC,mBAAmB,EAAE;EAClE,MAAMJ,MAAM,GAAG;IACbL,KAAK,EAAEnB,gBAAgB,CAAC2B,WAAW,CAAC9B,SAAS,EAAEhN,KAAK,CAAC;IACrDuO,GAAG,EAAEpB,gBAAgB,CAAC2B,WAAW,CAAC7B,OAAO,EAAEjN,KAAK;EAClD,CAAC;EACD,IAAI+O,mBAAmB,EAAE;IACvB,MAAMV,WAAW,GAAGrO,KAAK,CAACsK,SAAS,CAAC5C,KAAK,GAAG1H,KAAK,CAACsK,SAAS,CAAC3C,MAAM;IAClEwG,gBAAgB,CAACQ,MAAM,EAAEN,WAAW,CAAC;EACvC;EACA,OAAOM,MAAM;AACf;AACA,SAASK,eAAeA,CAAChP,KAAK,EAAEF,IAAI,EAAEgP,WAAW,EAAEC,mBAAmB,EAAE;EACtE,MAAMpE,QAAQ,GAAG9K,gBAAgB,CAACC,IAAI,EAAE,GAAG,EAAEE,KAAK,CAAC;EACnD,MAAM4K,QAAQ,GAAG/K,gBAAgB,CAACC,IAAI,EAAE,GAAG,EAAEE,KAAK,CAAC;EACnD,MAAM;IAACqB,GAAG;IAAEE,IAAI;IAAEC,KAAK;IAAEF,MAAM;IAAEoG,KAAK,EAAEuH,UAAU;IAAEtH,MAAM,EAAEuH;EAAW,CAAC,GAAGlP,KAAK,CAACsK,SAAS;EAC1F,MAAMoE,IAAI,GAAG;IAACrN,GAAG;IAAEE,IAAI;IAAEC,KAAK;IAAEF;EAAM,CAAC;EACvC,MAAMqN,MAAM,GAAGE,iBAAiB,CAAC7O,KAAK,EAAE8O,WAAW,EAAEC,mBAAmB,IAAIpE,QAAQ,IAAIC,QAAQ,CAAC;EACjG,IAAID,QAAQ,EAAE;IACZ8D,gBAAgB,CAACC,IAAI,EAAE1O,KAAK,CAACsK,SAAS,EAAEqE,MAAM,EAAE;MAACvL,GAAG,EAAE,MAAM;MAAEK,GAAG,EAAE,OAAO;MAAEwB,IAAI,EAAE;IAAG,CAAC,CAAC;EACzF;EACA,IAAI2F,QAAQ,EAAE;IACZ6D,gBAAgB,CAACC,IAAI,EAAE1O,KAAK,CAACsK,SAAS,EAAEqE,MAAM,EAAE;MAACvL,GAAG,EAAE,KAAK;MAAEK,GAAG,EAAE,QAAQ;MAAEwB,IAAI,EAAE;IAAG,CAAC,CAAC;EACzF;EACA,MAAMyC,KAAK,GAAGgH,IAAI,CAAClN,KAAK,GAAGkN,IAAI,CAACnN,IAAI;EACpC,MAAMoG,MAAM,GAAG+G,IAAI,CAACpN,MAAM,GAAGoN,IAAI,CAACrN,GAAG;EACrC,OAAO;IACL,GAAGqN,IAAI;IACPhH,KAAK;IACLC,MAAM;IACNwH,KAAK,EAAExE,QAAQ,IAAIjD,KAAK,GAAG,CAAC,GAAI,CAACuH,UAAU,GAAGvH,KAAK,IAAIuH,UAAW,GAAG,CAAC;IACtEG,KAAK,EAAExE,QAAQ,IAAIjD,MAAM,GAAG,CAAC,GAAI,CAACuH,WAAW,GAAGvH,MAAM,IAAIuH,WAAY,GAAG;EAC3E,CAAC;AACH;AACA,SAASG,OAAOA,CAACrP,KAAK,EAAEL,KAAK,EAAE;EAC7B,MAAM4C,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,IAAI,CAACuC,KAAK,CAACyK,SAAS,EAAE;IACpB;EACF;EACAT,aAAa,CAACvM,KAAK,EAAE,WAAW,CAAC;EACjC,MAAM;IAACF,IAAI;IAAEwL,cAAc;IAAEyC,IAAI,EAAE;MAACuB,SAAS,GAAG,CAAC;MAAEP;IAAmB;EAAC,CAAC,GAAGxM,KAAK,CAACb,OAAO,CAACsC,IAAI;EAC7F,MAAM0K,IAAI,GAAGM,eAAe,CAAChP,KAAK,EAAEF,IAAI,EAAE;IAACkN,SAAS,EAAEzK,KAAK,CAACyK,SAAS;IAAEC,OAAO,EAAEtN;EAAK,CAAC,EAAEoP,mBAAmB,CAAC;EAC5G,MAAMQ,SAAS,GAAG1P,gBAAgB,CAACC,IAAI,EAAE,GAAG,EAAEE,KAAK,CAAC,GAAG0O,IAAI,CAAChH,KAAK,GAAG,CAAC;EACrE,MAAM8H,SAAS,GAAG3P,gBAAgB,CAACC,IAAI,EAAE,GAAG,EAAEE,KAAK,CAAC,GAAG0O,IAAI,CAAC/G,MAAM,GAAG,CAAC;EACtE,MAAM8H,QAAQ,GAAGjM,IAAI,CAACkM,IAAI,CAACH,SAAS,GAAGA,SAAS,GAAGC,SAAS,GAAGA,SAAS,CAAC;EACzEjN,KAAK,CAACyK,SAAS,GAAGzK,KAAK,CAAC0K,OAAO,GAAG,IAAI;EACtC,IAAIwC,QAAQ,IAAIH,SAAS,EAAE;IACzB/M,KAAK,CAACM,QAAQ,GAAG,KAAK;IACtB7C,KAAK,CAAC6K,MAAM,CAAC,MAAM,CAAC;IACpB;EACF;EACAE,QAAQ,CAAC/K,KAAK,EAAE;IAACI,CAAC,EAAEsO,IAAI,CAACnN,IAAI;IAAElB,CAAC,EAAEqO,IAAI,CAACrN;EAAG,CAAC,EAAE;IAACjB,CAAC,EAAEsO,IAAI,CAAClN,KAAK;IAAEnB,CAAC,EAAEqO,IAAI,CAACpN;EAAM,CAAC,EAAE,MAAM,EAAE,MAAM,CAAC;EAC7FiB,KAAK,CAACM,QAAQ,GAAG,KAAK;EACtBN,KAAK,CAACoN,eAAe,GAAG,IAAI;EAC5B1Q,QAAQ,CAACqM,cAAc,EAAE,CAAC;IAACtL;EAAK,CAAC,CAAC,CAAC;AACrC;AACA,SAAS4P,kBAAkBA,CAAC5P,KAAK,EAAEL,KAAK,EAAE+K,WAAW,EAAE;EACrD,IAAI9K,aAAa,CAACP,cAAc,CAACqL,WAAW,CAACmF,KAAK,CAAC,EAAElQ,KAAK,CAAC,EAAE;IAC3DV,QAAQ,CAACyL,WAAW,CAACiD,cAAc,EAAE,CAAC;MAAC3N,KAAK;MAAEL;IAAK,CAAC,CAAC,CAAC;IACtD;EACF;EACA,IAAI8N,SAAS,CAACzN,KAAK,EAAEL,KAAK,EAAE+K,WAAW,CAAC,KAAK,KAAK,EAAE;IAClD;EACF;EACA,IAAI/K,KAAK,CAACmQ,UAAU,EAAE;IACpBnQ,KAAK,CAACoQ,cAAc,CAAC,CAAC;EACxB;EACA,IAAIpQ,KAAK,CAACqQ,MAAM,KAAK/P,SAAS,EAAE;IAC9B;EACF;EACA,OAAO,IAAI;AACb;AACA,SAAS4P,KAAKA,CAAC7P,KAAK,EAAEL,KAAK,EAAE;EAC3B,MAAM;IAACgD,QAAQ,EAAE;MAAC2I;IAAc,CAAC;IAAE5J,OAAO,EAAE;MAACsC,IAAI,EAAE0G;IAAW;EAAC,CAAC,GAAGpI,QAAQ,CAACtC,KAAK,CAAC;EAClF,IAAI,CAAC4P,kBAAkB,CAAC5P,KAAK,EAAEL,KAAK,EAAE+K,WAAW,CAAC,EAAE;IAClD;EACF;EACA,MAAMgE,IAAI,GAAG/O,KAAK,CAAC8M,MAAM,CAACa,qBAAqB,CAAC,CAAC;EACjD,MAAM2C,KAAK,GAAGvF,WAAW,CAACmF,KAAK,CAACI,KAAK;EACrC,MAAMC,UAAU,GAAGvQ,KAAK,CAACqQ,MAAM,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAGC,KAAK,CAAC,GAAG,CAAC,GAAGA,KAAK;EACtE,MAAMhG,MAAM,GAAG;IACb7J,CAAC,EAAE8P,UAAU;IACb7P,CAAC,EAAE6P,UAAU;IACbzF,UAAU,EAAE;MACVrK,CAAC,EAAET,KAAK,CAAC4N,OAAO,GAAGmB,IAAI,CAACnN,IAAI;MAC5BlB,CAAC,EAAEV,KAAK,CAAC6N,OAAO,GAAGkB,IAAI,CAACrN;IAC1B;EACF,CAAC;EACD2C,IAAI,CAAChE,KAAK,EAAEiK,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC;EACpChL,QAAQ,CAACqM,cAAc,EAAE,CAAC;IAACtL;EAAK,CAAC,CAAC,CAAC;AACrC;AACA,SAASmQ,mBAAmBA,CAACnQ,KAAK,EAAEoQ,IAAI,EAAE5D,OAAO,EAAEhM,KAAK,EAAE;EACxD,IAAIgM,OAAO,EAAE;IACXlK,QAAQ,CAACtC,KAAK,CAAC,CAAC2C,QAAQ,CAACyN,IAAI,CAAC,GAAG9P,QAAQ,CAAC,MAAMrB,QAAQ,CAACuN,OAAO,EAAE,CAAC;MAACxM;IAAK,CAAC,CAAC,CAAC,EAAEQ,KAAK,CAAC;EACtF;AACF;AACA,SAAS6P,YAAYA,CAACrQ,KAAK,EAAE0B,OAAO,EAAE;EACpC,MAAM0L,MAAM,GAAGpN,KAAK,CAACoN,MAAM;EAC3B,MAAM;IAACyC,KAAK,EAAES,YAAY;IAAEvC,IAAI,EAAEwC,WAAW;IAAEjF;EAAc,CAAC,GAAG5J,OAAO,CAACsC,IAAI;EAC7E,IAAIsM,YAAY,CAAC/Q,OAAO,EAAE;IACxBoN,UAAU,CAAC3M,KAAK,EAAEoN,MAAM,EAAE,OAAO,EAAEyC,KAAK,CAAC;IACzCM,mBAAmB,CAACnQ,KAAK,EAAE,gBAAgB,EAAEsL,cAAc,EAAE,GAAG,CAAC;EACnE,CAAC,MAAM;IACLiB,aAAa,CAACvM,KAAK,EAAE,OAAO,CAAC;EAC/B;EACA,IAAIuQ,WAAW,CAAChR,OAAO,EAAE;IACvBoN,UAAU,CAAC3M,KAAK,EAAEoN,MAAM,EAAE,WAAW,EAAEQ,SAAS,CAAC;IACjDjB,UAAU,CAAC3M,KAAK,EAAEoN,MAAM,CAACY,aAAa,EAAE,SAAS,EAAEqB,OAAO,CAAC;EAC7D,CAAC,MAAM;IACL9C,aAAa,CAACvM,KAAK,EAAE,WAAW,CAAC;IACjCuM,aAAa,CAACvM,KAAK,EAAE,WAAW,CAAC;IACjCuM,aAAa,CAACvM,KAAK,EAAE,SAAS,CAAC;IAC/BuM,aAAa,CAACvM,KAAK,EAAE,SAAS,CAAC;EACjC;AACF;AACA,SAASwQ,eAAeA,CAACxQ,KAAK,EAAE;EAC9BuM,aAAa,CAACvM,KAAK,EAAE,WAAW,CAAC;EACjCuM,aAAa,CAACvM,KAAK,EAAE,WAAW,CAAC;EACjCuM,aAAa,CAACvM,KAAK,EAAE,SAAS,CAAC;EAC/BuM,aAAa,CAACvM,KAAK,EAAE,OAAO,CAAC;EAC7BuM,aAAa,CAACvM,KAAK,EAAE,OAAO,CAAC;EAC7BuM,aAAa,CAACvM,KAAK,EAAE,SAAS,CAAC;AACjC;AAEA,SAASyQ,aAAaA,CAACzQ,KAAK,EAAEuC,KAAK,EAAE;EACnC,OAAO,UAASmO,UAAU,EAAE/Q,KAAK,EAAE;IACjC,MAAM;MAACiJ,GAAG,EAAEiD,UAAU;MAAE7H,IAAI,EAAE0G,WAAW,GAAG,CAAC;IAAC,CAAC,GAAGnI,KAAK,CAACb,OAAO;IAC/D,IAAI,CAACmK,UAAU,IAAI,CAACA,UAAU,CAACtM,OAAO,EAAE;MACtC,OAAO,KAAK;IACd;IACA,MAAMoR,QAAQ,GAAGhR,KAAK,IAAIA,KAAK,CAACgR,QAAQ;IACxC,IAAI,CAACA,QAAQ,EAAE;MACb,OAAO,IAAI;IACb;IACA,IAAI,CAACpO,KAAK,CAACO,OAAO,IAAInD,KAAK,CAACiR,WAAW,KAAK,OAAO,KACjDhR,aAAa,CAACP,cAAc,CAACwM,UAAU,CAAC,EAAE8E,QAAQ,CAAC,IAAIlR,UAAU,CAACJ,cAAc,CAACqL,WAAW,CAACqD,IAAI,CAAC,EAAE4C,QAAQ,CAAC,CAAC,EAC9G;MACA1R,QAAQ,CAAC4M,UAAU,CAACgF,aAAa,EAAE,CAAC;QAAC7Q,KAAK;QAAEL;MAAK,CAAC,CAAC,CAAC;MACpD,OAAO,KAAK;IACd;IACA,OAAO,IAAI;EACb,CAAC;AACH;AACA,SAASmR,SAASA,CAAC9F,EAAE,EAAEC,EAAE,EAAE;EACzB,MAAM8F,MAAM,GAAGvN,IAAI,CAACwE,GAAG,CAACgD,EAAE,CAACuC,OAAO,GAAGtC,EAAE,CAACsC,OAAO,CAAC;EAChD,MAAMyD,MAAM,GAAGxN,IAAI,CAACwE,GAAG,CAACgD,EAAE,CAACwC,OAAO,GAAGvC,EAAE,CAACuC,OAAO,CAAC;EAChD,MAAMyD,CAAC,GAAGF,MAAM,GAAGC,MAAM;EACzB,IAAI5Q,CAAC,EAAEC,CAAC;EACR,IAAI4Q,CAAC,GAAG,GAAG,IAAIA,CAAC,GAAG,GAAG,EAAE;IACtB7Q,CAAC,GAAGC,CAAC,GAAG,IAAI;EACd,CAAC,MAAM,IAAI0Q,MAAM,GAAGC,MAAM,EAAE;IAC1B5Q,CAAC,GAAG,IAAI;EACV,CAAC,MAAM;IACLC,CAAC,GAAG,IAAI;EACV;EACA,OAAO;IAACD,CAAC;IAAEC;EAAC,CAAC;AACf;AACA,SAAS6Q,WAAWA,CAAClR,KAAK,EAAEuC,KAAK,EAAE4O,CAAC,EAAE;EACpC,IAAI5O,KAAK,CAACnB,KAAK,EAAE;IACf,MAAM;MAAC6C,MAAM;MAAEmN;IAAQ,CAAC,GAAGD,CAAC;IAC5B,MAAME,WAAW,GAAG,CAAC,GAAG9O,KAAK,CAACnB,KAAK,GAAG+P,CAAC,CAAC/P,KAAK;IAC7C,MAAMsN,IAAI,GAAGyC,CAAC,CAAC1E,MAAM,CAACa,qBAAqB,CAAC,CAAC;IAC7C,MAAMgE,KAAK,GAAGR,SAAS,CAACM,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;IACjD,MAAMtR,IAAI,GAAGyC,KAAK,CAACb,OAAO,CAACsC,IAAI,CAAClE,IAAI;IACpC,MAAMmK,MAAM,GAAG;MACb7J,CAAC,EAAEkR,KAAK,CAAClR,CAAC,IAAIP,gBAAgB,CAACC,IAAI,EAAE,GAAG,EAAEE,KAAK,CAAC,GAAGqR,WAAW,GAAG,CAAC;MAClEhR,CAAC,EAAEiR,KAAK,CAACjR,CAAC,IAAIR,gBAAgB,CAACC,IAAI,EAAE,GAAG,EAAEE,KAAK,CAAC,GAAGqR,WAAW,GAAG,CAAC;MAClE5G,UAAU,EAAE;QACVrK,CAAC,EAAE6D,MAAM,CAAC7D,CAAC,GAAGsO,IAAI,CAACnN,IAAI;QACvBlB,CAAC,EAAE4D,MAAM,CAAC5D,CAAC,GAAGqO,IAAI,CAACrN;MACrB;IACF,CAAC;IACD2C,IAAI,CAAChE,KAAK,EAAEiK,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC;IACpC1H,KAAK,CAACnB,KAAK,GAAG+P,CAAC,CAAC/P,KAAK;EACvB;AACF;AACA,SAASmQ,UAAUA,CAACvR,KAAK,EAAEuC,KAAK,EAAE5C,KAAK,EAAE;EACvC,IAAI4C,KAAK,CAACb,OAAO,CAACsC,IAAI,CAACsN,KAAK,CAAC/R,OAAO,EAAE;IACpC,MAAMoC,KAAK,GAAGxC,mBAAmB,CAACQ,KAAK,EAAEK,KAAK,CAAC;IAC/C,IAAIf,QAAQ,CAACsD,KAAK,CAACb,OAAO,CAACsC,IAAI,CAAC0J,WAAW,EAAE,CAAC;MAAC1N,KAAK;MAAEL,KAAK;MAAEgC;IAAK,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;MAC/EY,KAAK,CAACnB,KAAK,GAAG,IAAI;MAClBnC,QAAQ,CAACsD,KAAK,CAACb,OAAO,CAACsC,IAAI,CAAC2J,cAAc,EAAE,CAAC;QAAC3N,KAAK;QAAEL;MAAK,CAAC,CAAC,CAAC;IAC/D,CAAC,MAAM;MACL4C,KAAK,CAACnB,KAAK,GAAG,CAAC;IACjB;EACF;AACF;AACA,SAASoQ,QAAQA,CAACxR,KAAK,EAAEuC,KAAK,EAAE4O,CAAC,EAAE;EACjC,IAAI5O,KAAK,CAACnB,KAAK,EAAE;IACf8P,WAAW,CAAClR,KAAK,EAAEuC,KAAK,EAAE4O,CAAC,CAAC;IAC5B5O,KAAK,CAACnB,KAAK,GAAG,IAAI;IAClBnC,QAAQ,CAACsD,KAAK,CAACb,OAAO,CAACsC,IAAI,CAACsH,cAAc,EAAE,CAAC;MAACtL;IAAK,CAAC,CAAC,CAAC;EACxD;AACF;AACA,SAASyR,SAASA,CAACzR,KAAK,EAAEuC,KAAK,EAAE4O,CAAC,EAAE;EAClC,MAAMzM,KAAK,GAAGnC,KAAK,CAACmC,KAAK;EACzB,IAAIA,KAAK,EAAE;IACTnC,KAAK,CAACO,OAAO,GAAG,IAAI;IACpB8F,GAAG,CAAC5I,KAAK,EAAE;MAACI,CAAC,EAAE+Q,CAAC,CAACO,MAAM,GAAGhN,KAAK,CAACtE,CAAC;MAAEC,CAAC,EAAE8Q,CAAC,CAACnB,MAAM,GAAGtL,KAAK,CAACrE;IAAC,CAAC,EAAEkC,KAAK,CAACoP,SAAS,CAAC;IAC3EpP,KAAK,CAACmC,KAAK,GAAG;MAACtE,CAAC,EAAE+Q,CAAC,CAACO,MAAM;MAAErR,CAAC,EAAE8Q,CAAC,CAACnB;IAAM,CAAC;EAC1C;AACF;AACA,SAAS4B,QAAQA,CAAC5R,KAAK,EAAEuC,KAAK,EAAE5C,KAAK,EAAE;EACrC,MAAM;IAACJ,OAAO;IAAEsS,UAAU;IAAEhB;EAAa,CAAC,GAAGtO,KAAK,CAACb,OAAO,CAACkH,GAAG;EAC9D,IAAI,CAACrJ,OAAO,EAAE;IACZ;EACF;EACA,MAAMmP,IAAI,GAAG/O,KAAK,CAAC8M,MAAM,CAACa,qBAAqB,CAAC,CAAC;EACjD,MAAM3L,KAAK,GAAG;IACZvB,CAAC,EAAET,KAAK,CAACsE,MAAM,CAAC7D,CAAC,GAAGsO,IAAI,CAACnN,IAAI;IAC7BlB,CAAC,EAAEV,KAAK,CAACsE,MAAM,CAAC5D,CAAC,GAAGqO,IAAI,CAACrN;EAC3B,CAAC;EACD,IAAIpC,QAAQ,CAAC4S,UAAU,EAAE,CAAC;IAAC7R,KAAK;IAAEL,KAAK;IAAEgC;EAAK,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;IAC3D,OAAO1C,QAAQ,CAAC4R,aAAa,EAAE,CAAC;MAAC7Q,KAAK;MAAEL;IAAK,CAAC,CAAC,CAAC;EAClD;EACA4C,KAAK,CAACoP,SAAS,GAAGlQ,uBAAuB,CAACc,KAAK,CAACb,OAAO,CAACkH,GAAG,EAAEjH,KAAK,EAAE3B,KAAK,CAAC;EAC1EuC,KAAK,CAACmC,KAAK,GAAG;IAACtE,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAC,CAAC;EAC1BoR,SAAS,CAACzR,KAAK,EAAEuC,KAAK,EAAE5C,KAAK,CAAC;AAChC;AACA,SAASmS,MAAMA,CAAC9R,KAAK,EAAEuC,KAAK,EAAE;EAC5BA,KAAK,CAACmC,KAAK,GAAG,IAAI;EAClB,IAAInC,KAAK,CAACO,OAAO,EAAE;IACjBP,KAAK,CAACO,OAAO,GAAG,KAAK;IACrBP,KAAK,CAACoN,eAAe,GAAG,IAAI;IAC5B1Q,QAAQ,CAACsD,KAAK,CAACb,OAAO,CAACkH,GAAG,CAACmJ,aAAa,EAAE,CAAC;MAAC/R;IAAK,CAAC,CAAC,CAAC;EACtD;AACF;AACA,MAAMgS,OAAO,GAAG,IAAI3P,OAAO,CAAC,CAAC;AAC7B,SAAS4P,WAAWA,CAACjS,KAAK,EAAE0B,OAAO,EAAE;EACnC,MAAMa,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;EAC7B,MAAMoN,MAAM,GAAGpN,KAAK,CAACoN,MAAM;EAC3B,MAAM;IAACxE,GAAG,EAAEiD,UAAU;IAAE7H,IAAI,EAAE0G;EAAW,CAAC,GAAGhJ,OAAO;EACpD,MAAMwQ,EAAE,GAAG,IAAIrT,MAAM,CAACsT,OAAO,CAAC/E,MAAM,CAAC;EACrC,IAAI1C,WAAW,IAAIA,WAAW,CAAC4G,KAAK,CAAC/R,OAAO,EAAE;IAC5C2S,EAAE,CAACE,GAAG,CAAC,IAAIvT,MAAM,CAACwT,KAAK,CAAC,CAAC,CAAC;IAC1BH,EAAE,CAACI,EAAE,CAAC,YAAY,EAAGnB,CAAC,IAAKI,UAAU,CAACvR,KAAK,EAAEuC,KAAK,EAAE4O,CAAC,CAAC,CAAC;IACvDe,EAAE,CAACI,EAAE,CAAC,OAAO,EAAGnB,CAAC,IAAKD,WAAW,CAAClR,KAAK,EAAEuC,KAAK,EAAE4O,CAAC,CAAC,CAAC;IACnDe,EAAE,CAACI,EAAE,CAAC,UAAU,EAAGnB,CAAC,IAAKK,QAAQ,CAACxR,KAAK,EAAEuC,KAAK,EAAE4O,CAAC,CAAC,CAAC;EACrD;EACA,IAAItF,UAAU,IAAIA,UAAU,CAACtM,OAAO,EAAE;IACpC2S,EAAE,CAACE,GAAG,CAAC,IAAIvT,MAAM,CAAC0T,GAAG,CAAC;MACpBjD,SAAS,EAAEzD,UAAU,CAACyD,SAAS;MAC/BkD,MAAM,EAAE/B,aAAa,CAACzQ,KAAK,EAAEuC,KAAK;IACpC,CAAC,CAAC,CAAC;IACH2P,EAAE,CAACI,EAAE,CAAC,UAAU,EAAGnB,CAAC,IAAKS,QAAQ,CAAC5R,KAAK,EAAEuC,KAAK,EAAE4O,CAAC,CAAC,CAAC;IACnDe,EAAE,CAACI,EAAE,CAAC,SAAS,EAAGnB,CAAC,IAAKM,SAAS,CAACzR,KAAK,EAAEuC,KAAK,EAAE4O,CAAC,CAAC,CAAC;IACnDe,EAAE,CAACI,EAAE,CAAC,QAAQ,EAAE,MAAMR,MAAM,CAAC9R,KAAK,EAAEuC,KAAK,CAAC,CAAC;EAC7C;EACAyP,OAAO,CAACjP,GAAG,CAAC/C,KAAK,EAAEkS,EAAE,CAAC;AACxB;AACA,SAASO,UAAUA,CAACzS,KAAK,EAAE;EACzB,MAAMkS,EAAE,GAAGF,OAAO,CAACxP,GAAG,CAACxC,KAAK,CAAC;EAC7B,IAAIkS,EAAE,EAAE;IACNA,EAAE,CAACQ,MAAM,CAAC,YAAY,CAAC;IACvBR,EAAE,CAACQ,MAAM,CAAC,OAAO,CAAC;IAClBR,EAAE,CAACQ,MAAM,CAAC,UAAU,CAAC;IACrBR,EAAE,CAACQ,MAAM,CAAC,UAAU,CAAC;IACrBR,EAAE,CAACQ,MAAM,CAAC,KAAK,CAAC;IAChBR,EAAE,CAACQ,MAAM,CAAC,QAAQ,CAAC;IACnBR,EAAE,CAACS,OAAO,CAAC,CAAC;IACZX,OAAO,CAAC/O,MAAM,CAACjD,KAAK,CAAC;EACvB;AACF;AACA,SAAS4S,oBAAoBA,CAACC,UAAU,EAAEC,UAAU,EAAE;EACpD,MAAM;IAAClK,GAAG,EAAEmK,MAAM;IAAE/O,IAAI,EAAEgP;EAAO,CAAC,GAAGH,UAAU;EAC/C,MAAM;IAACjK,GAAG,EAAEqK,MAAM;IAAEjP,IAAI,EAAEkP;EAAO,CAAC,GAAGJ,UAAU;EAC/C,IAAIE,OAAO,EAAEhP,IAAI,EAAEsN,KAAK,EAAE/R,OAAO,KAAK2T,OAAO,EAAElP,IAAI,EAAEsN,KAAK,EAAE/R,OAAO,EAAE;IACnE,OAAO,IAAI;EACb;EACA,IAAIwT,MAAM,EAAExT,OAAO,KAAK0T,MAAM,EAAE1T,OAAO,EAAE;IACvC,OAAO,IAAI;EACb;EACA,IAAIwT,MAAM,EAAEzD,SAAS,KAAK2D,MAAM,EAAE3D,SAAS,EAAE;IAC3C,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AAEA,IAAI6D,OAAO,GAAG,OAAO;AAErB,SAASC,IAAIA,CAACpT,KAAK,EAAEqT,MAAM,EAAE3R,OAAO,EAAE;EACpC,MAAM6O,WAAW,GAAG7O,OAAO,CAACsC,IAAI,CAAC+J,IAAI;EACrC,MAAM;IAACf,SAAS;IAAEC;EAAO,CAAC,GAAG3K,QAAQ,CAACtC,KAAK,CAAC;EAC5C,IAAIuQ,WAAW,CAAC+C,QAAQ,KAAKD,MAAM,IAAI,CAACpG,OAAO,EAAE;IAC/C;EACF;EACA,MAAM;IAAC1L,IAAI;IAAEF,GAAG;IAAEqG,KAAK;IAAEC;EAAM,CAAC,GAAGqH,eAAe,CAAChP,KAAK,EAAE0B,OAAO,CAACsC,IAAI,CAAClE,IAAI,EAAE;IAACkN,SAAS;IAAEC;EAAO,CAAC,EAAEsD,WAAW,CAACxB,mBAAmB,CAAC;EACnI,MAAMwE,GAAG,GAAGvT,KAAK,CAACuT,GAAG;EACrBA,GAAG,CAACC,IAAI,CAAC,CAAC;EACVD,GAAG,CAACE,SAAS,CAAC,CAAC;EACfF,GAAG,CAACG,SAAS,GAAGnD,WAAW,CAACoD,eAAe,IAAI,uBAAuB;EACtEJ,GAAG,CAACK,QAAQ,CAACrS,IAAI,EAAEF,GAAG,EAAEqG,KAAK,EAAEC,MAAM,CAAC;EACtC,IAAI4I,WAAW,CAACsD,WAAW,GAAG,CAAC,EAAE;IAC/BN,GAAG,CAACO,SAAS,GAAGvD,WAAW,CAACsD,WAAW;IACvCN,GAAG,CAACQ,WAAW,GAAGxD,WAAW,CAACyD,WAAW,IAAI,mBAAmB;IAChET,GAAG,CAACU,UAAU,CAAC1S,IAAI,EAAEF,GAAG,EAAEqG,KAAK,EAAEC,MAAM,CAAC;EAC1C;EACA4L,GAAG,CAACW,OAAO,CAAC,CAAC;AACf;AACA,IAAIC,MAAM,GAAG;EACXrP,EAAE,EAAE,MAAM;EACVqO,OAAO;EACPiB,QAAQ,EAAE;IACRxL,GAAG,EAAE;MACHrJ,OAAO,EAAE,KAAK;MACdO,IAAI,EAAE,IAAI;MACVwP,SAAS,EAAE,EAAE;MACb9P,WAAW,EAAE;IACf,CAAC;IACDwE,IAAI,EAAE;MACJ6L,KAAK,EAAE;QACLtQ,OAAO,EAAE,KAAK;QACd0Q,KAAK,EAAE,GAAG;QACVzQ,WAAW,EAAE;MACf,CAAC;MACDuO,IAAI,EAAE;QACJxO,OAAO,EAAE,KAAK;QACd+T,QAAQ,EAAE,oBAAoB;QAC9B9T,WAAW,EAAE;MACf,CAAC;MACD8R,KAAK,EAAE;QACL/R,OAAO,EAAE;MACX,CAAC;MACDO,IAAI,EAAE;IACR;EACF,CAAC;EACDuU,KAAK,EAAE,SAAAA,CAASrU,KAAK,EAAEsU,KAAK,EAAE5S,OAAO,EAAE;IACrC,MAAMa,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;IAC7BuC,KAAK,CAACb,OAAO,GAAGA,OAAO;IACvB,IAAIV,MAAM,CAACuT,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC/S,OAAO,CAACsC,IAAI,EAAE,SAAS,CAAC,EAAE;MACjE0Q,OAAO,CAACC,IAAI,CAAC,kIAAkI,CAAC;IAClJ;IACA,IAAI3T,MAAM,CAACuT,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC/S,OAAO,CAACsC,IAAI,EAAE,eAAe,CAAC,IAClEhD,MAAM,CAACuT,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC/S,OAAO,CAACkH,GAAG,EAAE,eAAe,CAAC,EAAE;MACvE8L,OAAO,CAACC,IAAI,CAAC,0GAA0G,CAAC;IAC1H;IACA,IAAI9V,MAAM,EAAE;MACVoT,WAAW,CAACjS,KAAK,EAAE0B,OAAO,CAAC;IAC7B;IACA1B,KAAK,CAAC4I,GAAG,GAAG,CAAClE,KAAK,EAAEiN,SAAS,EAAEpH,UAAU,KAAK3B,GAAG,CAAC5I,KAAK,EAAE0E,KAAK,EAAEiN,SAAS,EAAEpH,UAAU,CAAC;IACtFvK,KAAK,CAACgE,IAAI,GAAG,CAAC4Q,IAAI,EAAErK,UAAU,KAAKvG,IAAI,CAAChE,KAAK,EAAE4U,IAAI,EAAErK,UAAU,CAAC;IAChEvK,KAAK,CAAC+K,QAAQ,GAAG,CAACC,EAAE,EAAEC,EAAE,EAAEV,UAAU,KAAKQ,QAAQ,CAAC/K,KAAK,EAAEgL,EAAE,EAAEC,EAAE,EAAEV,UAAU,CAAC;IAC5EvK,KAAK,CAACkL,SAAS,GAAG,CAACpG,EAAE,EAAEzB,KAAK,EAAEkH,UAAU,KAAKW,SAAS,CAAClL,KAAK,EAAE8E,EAAE,EAAEzB,KAAK,EAAEkH,UAAU,CAAC;IACpFvK,KAAK,CAACoL,SAAS,GAAIb,UAAU,IAAKa,SAAS,CAACpL,KAAK,EAAEuK,UAAU,CAAC;IAC9DvK,KAAK,CAACwL,YAAY,GAAG,MAAMA,YAAY,CAACxL,KAAK,CAAC;IAC9CA,KAAK,CAAC+L,qBAAqB,GAAG,MAAMA,qBAAqB,CAAC/L,KAAK,CAAC;IAChEA,KAAK,CAACiM,oBAAoB,GAAG,MAAMA,oBAAoB,CAACjM,KAAK,CAAC;IAC9DA,KAAK,CAACkM,gBAAgB,GAAG,MAAMA,gBAAgB,CAAClM,KAAK,CAAC;IACtDA,KAAK,CAACqM,kBAAkB,GAAG,MAAMA,kBAAkB,CAACrM,KAAK,CAAC;EAC5D,CAAC;EACD6U,WAAWA,CAAC7U,KAAK,EAAA8U,KAAA,EAAW;IAAA,IAAT;MAACnV;IAAK,CAAC,GAAAmV,KAAA;IACxB,IAAIzI,kBAAkB,CAACrM,KAAK,CAAC,EAAE;MAC7B,OAAO,KAAK;IACd;IACA,IAAIL,KAAK,CAACuK,IAAI,KAAK,OAAO,IAAIvK,KAAK,CAACuK,IAAI,KAAK,SAAS,EAAE;MACtD,MAAM3H,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;MAC7B,IAAIuC,KAAK,CAACoN,eAAe,EAAE;QACzBpN,KAAK,CAACoN,eAAe,GAAG,KAAK;QAC7B,OAAO,KAAK;MACd;IACF;EACF,CAAC;EACDoF,YAAY,EAAE,SAAAA,CAAS/U,KAAK,EAAE4U,IAAI,EAAElT,OAAO,EAAE;IAC3C,MAAMa,KAAK,GAAGD,QAAQ,CAACtC,KAAK,CAAC;IAC7B,MAAMgV,eAAe,GAAGzS,KAAK,CAACb,OAAO;IACrCa,KAAK,CAACb,OAAO,GAAGA,OAAO;IACvB,IAAIkR,oBAAoB,CAACoC,eAAe,EAAEtT,OAAO,CAAC,EAAE;MAClD+Q,UAAU,CAACzS,KAAK,CAAC;MACjBiS,WAAW,CAACjS,KAAK,EAAE0B,OAAO,CAAC;IAC7B;IACA2O,YAAY,CAACrQ,KAAK,EAAE0B,OAAO,CAAC;EAC9B,CAAC;EACDuT,kBAAkBA,CAACjV,KAAK,EAAEsU,KAAK,EAAE5S,OAAO,EAAE;IACxC0R,IAAI,CAACpT,KAAK,EAAE,oBAAoB,EAAE0B,OAAO,CAAC;EAC5C,CAAC;EACDwT,iBAAiBA,CAAClV,KAAK,EAAEsU,KAAK,EAAE5S,OAAO,EAAE;IACvC0R,IAAI,CAACpT,KAAK,EAAE,mBAAmB,EAAE0B,OAAO,CAAC;EAC3C,CAAC;EACDyT,UAAUA,CAACnV,KAAK,EAAEsU,KAAK,EAAE5S,OAAO,EAAE;IAChC0R,IAAI,CAACpT,KAAK,EAAE,YAAY,EAAE0B,OAAO,CAAC;EACpC,CAAC;EACD0T,SAASA,CAACpV,KAAK,EAAEsU,KAAK,EAAE5S,OAAO,EAAE;IAC/B0R,IAAI,CAACpT,KAAK,EAAE,WAAW,EAAE0B,OAAO,CAAC;EACnC,CAAC;EACD2T,IAAI,EAAE,SAAAA,CAASrV,KAAK,EAAE;IACpBwQ,eAAe,CAACxQ,KAAK,CAAC;IACtB,IAAInB,MAAM,EAAE;MACV4T,UAAU,CAACzS,KAAK,CAAC;IACnB;IACAgD,WAAW,CAAChD,KAAK,CAAC;EACpB,CAAC;EACDyJ,YAAY;EACZL,aAAa;EACbI;AACF,CAAC;AAED,SAAS2K,MAAM,IAAI7K,OAAO,EAAEV,GAAG,EAAEwC,SAAS,EAAEpH,IAAI,EAAE+G,QAAQ,EAAEG,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}